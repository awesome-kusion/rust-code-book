<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Source Code Analysis</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="é€šè¿‡åˆ†æä»£ç å­¦ä¹ Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="style.css">
        
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Rust Source Code Analysis</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="stdlib/index.html"><strong aria-hidden="true">2.</strong> Standard Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stdlib/sort/index.html"><strong aria-hidden="true">2.1.</strong> Sort: Timsort and pdqsort[WIP: Zh-ver.]</a></li></ol></li><li class="chapter-item expanded "><a href="rustc/index.html"><strong aria-hidden="true">3.</strong> Rust Compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustc/overview/index.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="rustc/invocation/index.html"><strong aria-hidden="true">3.2.</strong> Invocation</a></li><li class="chapter-item expanded "><a href="rustc/lexer/index.html"><strong aria-hidden="true">3.3.</strong> Lexer</a></li><li class="chapter-item expanded "><a href="rustc/parser/index.html"><strong aria-hidden="true">3.4.</strong> Parser</a></li><li class="chapter-item expanded "><a href="rustc/sema/index.html"><strong aria-hidden="true">3.5.</strong> Sema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustc/sema/lint/index.html"><strong aria-hidden="true">3.5.1.</strong> Lint</a></li></ol></li><li class="chapter-item expanded "><a href="rustc/codegen/index.html"><strong aria-hidden="true">3.6.</strong> Codegen</a></li><li class="chapter-item expanded "><a href="rustc/general/index.html"><strong aria-hidden="true">3.7.</strong> General</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rustc/general/errors/index.html"><strong aria-hidden="true">3.7.1.</strong> Errors[WIP: Zh-ver.]</a></li><li class="chapter-item expanded "><a href="rustc/general/sourcemap-span/index.html"><strong aria-hidden="true">3.7.2.</strong> SourceMap &amp; Span[WIP]</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rust-tools/index.html"><strong aria-hidden="true">4.</strong> Rust Tools</a></li><li class="chapter-item expanded "><a href="open-source/index.html"><strong aria-hidden="true">5.</strong> Rust Open Source Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="open-source/KCLVM/index.html"><strong aria-hidden="true">5.1.</strong> KCLVM</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">6.</strong> Appendix</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust Source Code Analysis</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/awesome-kusion/rust-code-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <!-- å¤´éƒ¨ -->
                                                
                        <h1 id="rust-source-code-analysis"><a class="header" href="#rust-source-code-analysis">Rust Source Code Analysis</a></h1>
<p>Target: Analysis and learn from the source code of Rust standard library, Rust compiler(Rustc) and open source project written by Rust.</p>
<p><img src="cover-full.png" alt="cover" /></p>
<ul>
<li>Github Repo: <a href="https://github.com/awesome-kusion/rust-code-book">https://github.com/awesome-kusion/rust-code-book</a></li>
<li>Read Online: <a href="https://awesome-kusion.github.io/rust-code-book">https://awesome-kusion.github.io/rust-code-book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>When I was working on KusionStack and KCLVM projects, I started to learn the source code of Rustc with the idea of learning the design of excellent compiler. I took some notes and documents during this process. With the suggestion of <a href="https://github.com/chai2010">Chai</a>, I organized them into an article and posted it. I didn't expect people to be interested in it, so I decided to continue writing articles on Rustc source code analysis. This is the original intention of writing this e-book.</p>
<p>KCLVM is a compiler we developed with Rust in the project of Kusion, and some parts of this book are applied to KCLVM. If you are interested in the cloud-native ecology and technology, you can learn about the project ğŸ‘‰ <a href="https://github.com/KusionStack/kusion">KusionStack</a>. And if you are interested in Rust, programming languages or compilers, maybe you prefer ğŸ‘‰ <a href="https://github.com/KusionStack/KCLVM">KCLVM</a>.</p>
<p>Finally, most of the content in these e-book are my personal understanding when reading the source code, as well as some descriptions in the <a href="https://rustc-dev-guide.rust-lang.org/about-this-guide.html">rust-dev-guide</a>. Owing to the limitation of my knowledge, there must be mistakes and errors in the book. So we welcome all forms of conrtibutions(fix typo/polish english/translation/write article or other) from everyone.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç®€ä»‹"><a class="header" href="#ç®€ä»‹">ç®€ä»‹</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<ul>
<li><a href="stdlib/../stdlib/sort/readme.html">sort: Timsort and pdqsort</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ’åºç®—æ³•-timsort-å’Œ-pdqsort"><a class="header" href="#æ’åºç®—æ³•-timsort-å’Œ-pdqsort">æ’åºç®—æ³•: Timsort å’Œ pdqsort</a></h1>
<h2 id="å‰è¨€"><a class="header" href="#å‰è¨€">å‰è¨€</a></h2>
<p>Rust ä¸­æ’åºç®—æ³•çš„å®ç°å¯ä»¥åˆ†ä¸ºç¨³å®šå’Œä¸ç¨³å®šçš„ä¸¤ç±»ã€‚å…¶ä¸­ç¨³å®šçš„æ’åºç®—æ³•æ˜¯ä¸€ç§å— Tim Peters çš„ <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> ç®—æ³•å¯å‘çš„è‡ªé€‚åº”ã€è¿­ä»£å½’å¹¶æ’åºï¼›è€Œä¸ç¨³å®šçš„æ’åºç®—æ³•åˆ™æ˜¯åŸºäº Orson Peters çš„ <a href="https://github.com/orlp/pdqsort">pdqsort</a>[pattern-defeating quicksort]ã€‚æœ¬æ–‡å°†ä»‹ç»è¿™ä¸¤ä¸ªç®—æ³•åœ¨ Rust ä¸­çš„å®ç°ã€‚</p>
<h2 id="ç¨³å®šæ’åº-timsort"><a class="header" href="#ç¨³å®šæ’åº-timsort">ç¨³å®šæ’åºï¼š Timsort</a></h2>
<p>ç¨³å®šæ’åºæ˜¯æŒ‡åœ¨æ’åºè¿‡ç¨‹ä¸­ä¸æ”¹å˜ç›¸ç­‰çš„å…ƒç´ çš„é¡ºåºã€‚ Rust ä¸­çš„ç¨³å®šæ’åºçš„å®ç°æ˜¯ä¸€ç§æ”¹è¿›çš„ timsort ç®—æ³•ã€‚å¯ä»¥åœ¨ <code>libray:alloc:src:slice.rs</code> ä¸­çœ‹åˆ°å®ƒçš„å®ç°ã€‚</p>
<h3 id="timsort-ç®€ä»‹"><a class="header" href="#timsort-ç®€ä»‹">Timsort ç®€ä»‹</a></h3>
<p>Timsort ç®—æ³•ç”± Tim Peters åœ¨ 2002 å¹´è®¾è®¡ï¼Œæ˜¯ä¸€ç§å½’å¹¶å’Œæ’å…¥æ’åºçš„æ··åˆçš„æ’åºç®—æ³•ã€‚åœ¨æœ€åçš„æƒ…å†µï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦ä¸º <em>O</em>(<em>n</em> * log(<em>n</em>))ï¼Œéœ€è¦åˆ†é…æ’åºçš„æ•°ç»„ä¸€åŠå¤§å°çš„å†…å­˜ç©ºé—´ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä¸º <em>O</em>(<em>n</em>)ï¼Œæ‰€ä»¥åœ¨å„ä¸ªæ–¹é¢éƒ½ä¼˜äº<em>O</em>(<em>n</em>)ç©ºé—´å’Œç¨³å®š<em>O</em>(<em>n</em> * log(<em>n</em>))æ—¶é—´çš„å½’å¹¶æ’åºç®—æ³•ã€‚ç”±äºå…¶å‡ºè‰²çš„æ€§èƒ½ï¼Œåœ¨ Python ä¸­æœ€å…ˆå¼•å…¥ï¼Œä½œä¸º list.sort çš„é»˜è®¤å®ç°ï¼Œåç»­ Java ä¹Ÿåœ¨ JDK1.7 ä¸­ä½¿ç”¨äº† Timsort ç®—æ³•ã€‚</p>
<p>Timsort ç®—æ³•çš„åŸºæœ¬æµç¨‹æ˜¯ï¼š</p>
<ol>
<li>ç¡®å®šæ•°ç»„çš„å•è°ƒä¸Šå‡æ®µå’Œä¸¥æ ¼å•è°ƒä¸‹é™æ®µï¼Œå¹¶å°†ä¸¥æ ¼ä¸‹é™æ®µåè½¬</li>
<li>å®šä¹‰æœ€å°ç‰‡æ®µ(run)é•¿åº¦ï¼Œä½äºæ­¤é•¿åº¦çš„ç‰‡æ®µé€šè¿‡æ’å…¥æ’åºåˆå¹¶åˆ°è¾ƒé•¿çš„æ®µä¸­</li>
<li>åå¤å½’å¹¶ç›¸é‚»ç‰‡æ®µï¼Œç›´åˆ°æ•´ä¸ªæ’åºå®Œæˆ</li>
</ol>
<p>å› æ­¤ï¼ŒTimsort åŸºæœ¬ä¸Šæ˜¯ä¸€ç§å½’å¹¶æ’åºï¼Œä½†æ˜¯åœ¨ä¸€äº›å°ç‰‡æ®µçš„åˆå¹¶ä¸­ä½¿ç”¨äº†æ’å…¥æ’åºã€‚</p>
<h3 id="ç®—æ³•å®ç°"><a class="header" href="#ç®—æ³•å®ç°">ç®—æ³•å®ç°</a></h3>
<p>å¯ä»¥åœ¨ <code>libray:alloc:src:slice.rs</code> ä¸­çœ‹åˆ° Rust ä¸­ Timsort ç®—æ³•çš„å®ç°ã€‚</p>
<h4 id="ç©ºæ•°ç»„å’ŒçŸ­æ•°ç»„å¤„ç†"><a class="header" href="#ç©ºæ•°ç»„å’ŒçŸ­æ•°ç»„å¤„ç†">ç©ºæ•°ç»„å’ŒçŸ­æ•°ç»„å¤„ç†</a></h4>
<p>é¦–å…ˆæ˜¯ä¸€äº›ç‰¹æ®Šæƒ…å†µçš„å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merge_sort&lt;T, F&gt;(v: &amp;mut [T], mut is_less: F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    // Slices of up to this length get sorted using insertion sort.
    const MAX_INSERTION: usize = 20;
        // Sorting has no meaningful behavior on zero-sized types.
    if T::IS_ZST {
        return;
    }
    let len = v.len();
    // Short arrays get sorted in-place via insertion sort to avoid allocations.
    if len &lt;= MAX_INSERTION {
        if len &gt;= 2 {
            for i in (0..len - 1).rev() {
                insert_head(&amp;mut v[i..], &amp;mut is_less);
            }
        }
        return;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>è¿™æ®µéå¸¸å®¹æ˜“ç†è§£ï¼Œå¦‚æœæ˜¯ç©ºæ•°ç»„å°±ç›´æ¥è¿”å›ï¼›å¦‚æœæ˜¯æ¯”è¾ƒçŸ­çš„æ•°ç»„ï¼ˆä½äº20ï¼‰ï¼Œå°±ç›´æ¥ç”¨ç®€å•çš„æ’å…¥æ’åºã€‚</p>
<h4 id="æ‰«ææ•°ç»„ç¡®å®šå•è°ƒç‰‡æ®µ"><a class="header" href="#æ‰«ææ•°ç»„ç¡®å®šå•è°ƒç‰‡æ®µ">æ‰«ææ•°ç»„ï¼Œç¡®å®šå•è°ƒç‰‡æ®µ</a></h4>
<p>Timsort ç®—æ³•çš„ç¬¬ä¸€æ­¥æ˜¯è¯†åˆ«å•è°ƒç‰‡æ®µ(run)ï¼šå•è°ƒé€’å¢ç‰‡æ®µå’Œä¸¥æ ¼å•è°ƒé€’å‡ç‰‡æ®µï¼Œå¹¶å°†ä¸¥æ ¼å•è°ƒé€’å‡ç‰‡æ®µåè½¬ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merge_sort&lt;T, F&gt;(v: &amp;mut [T], mut is_less: F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    let mut end = len;
    while end &gt; 0 {
        let mut start = end - 1;
        if start &gt; 0 {
            start -= 1;
            unsafe {
                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {
                    while start &gt; 0 &amp;&amp; is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {
                        start -= 1;
                    }
                    v[start..end].reverse();
                } else {
                    while start &gt; 0 &amp;&amp; !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))
                    {
                        start -= 1;
                    }
                }
            }
        }
    ...
    }
}


<span class="boring">}
</span></code></pre></pre>
<p>é¦–å…ˆä»åå‘å‰éå†æ•°ç»„ï¼Œæ‰¾åˆ°å•è°ƒé€’å¢æˆ–ä¸¥æ ¼å•è°ƒé€’å‡çš„æ®µçš„èµ·ç‚¹ï¼Œå¹¶å°†ä¸¥æ ¼å•è°ƒé€’å‡çš„æ®µåè½¬ã€‚ä»¥æ•°ç»„<code>[4ï¼Œ5ï¼Œ6, 7, 3(1), 3(2), 1, 0]</code>ä¸ºä¾‹ï¼ˆä¸ºäº†ç®€åŒ–æ©é¥°ï¼Œæš‚ä¸è€ƒè™‘<code>MAX_INSERTION</code>ï¼‰ï¼Œé¦–å…ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸¥æ ¼å•è°ƒé€’å‡æ®µ<code>[3(2), 1, 0]</code>ï¼Œå¹¶å°†å…¶åè½¬ä¸º<code>[0, 1, 3(2)]</code>ã€‚</p>
<h4 id="åˆå¹¶è¾ƒçŸ­çš„æ®µ"><a class="header" href="#åˆå¹¶è¾ƒçŸ­çš„æ®µ">åˆå¹¶è¾ƒçŸ­çš„æ®µ</a></h4>
<p>åœ¨è¾ƒçŸ­çš„æ•°ç»„ä¸Šï¼Œæ’å…¥æ’åºçš„æ€§èƒ½ä¼˜äºå½’å¹¶æ’åºã€‚æ‰€ä»¥ Timsort ç®—æ³•çš„ç¬¬äºŒæ­¥æ˜¯å®šä¹‰æœ€çŸ­æ®µé•¿åº¦ï¼Œå¹¶åˆ©ç”¨æ’å…¥æ’åºåˆå¹¶è¾ƒçŸ­çš„æ®µã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merge_sort&lt;T, F&gt;(v: &amp;mut [T], mut is_less: F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    const MIN_RUN: usize = 10;
    while end &gt; 0 {
        // omit step 1

        while start &gt; 0 &amp;&amp; end - start &lt; MIN_RUN {
            start -= 1;
            insert_head(&amp;mut v[start..end], &amp;mut is_less);
        }
        runs.push(Run { start, len: end - start });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ä¸Šè¿°çš„ä¾‹å­ä¸­ï¼ŒåŒæ ·ä¸ºäº†æ–¹ä¾¿æ¼”ç¤ºï¼Œå‡è®¾ <code>MIN_RUN</code> çš„å€¼ä¸º5ã€‚åˆ™æ ¹æ®ä¸Šè¿°ä»£ç ï¼Œä½¿ç”¨æ’å…¥æ’åºåœ¨æ®µä¸­æ’å…¥ <code>7</code> å’Œ <code>3(1)</code>ï¼Œåˆ™æ®µå˜ä¸º <code>[0, 1, 3(1), 3(2), 7]</code>ã€‚æœ€åå°†è¿™ä¸ªæ®µå…¥æ ˆã€‚</p>
<h4 id="åˆå¹¶ç›¸é‚»æ®µ"><a class="header" href="#åˆå¹¶ç›¸é‚»æ®µ">åˆå¹¶ç›¸é‚»æ®µ</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merge_sort&lt;T, F&gt;(v: &amp;mut [T], mut is_less: F)
where
    F: FnMut(&amp;T, &amp;T) -&gt; bool,
{
    const MIN_RUN: usize = 10;
    while end &gt; 0 {
        // omit step 1 and step 2
        while let Some(r) = collapse(&amp;runs) {
            let left = runs[r + 1];
            let right = runs[r];
            unsafe {
                merge(
                    &amp;mut v[left.start..right.start + right.len],
                    left.len,
                    buf.as_mut_ptr(),
                    &amp;mut is_less,
                );
            }
            runs[r] = Run { start: left.start, len: left.len + right.len };
            runs.remove(r + 1);
        }
    }
    fn collapse(runs: &amp;[Run]) -&gt; Option&lt;usize&gt; {
        let n = runs.len();
        if n &gt;= 2
            &amp;&amp; (runs[n - 1].start == 0
                || runs[n - 2].len &lt;= runs[n - 1].len
                || (n &gt;= 3 &amp;&amp; runs[n - 3].len &lt;= runs[n - 2].len + runs[n - 1].len)
                || (n &gt;= 4 &amp;&amp; runs[n - 4].len &lt;= runs[n - 3].len + runs[n - 2].len))
        {
            if n &gt;= 3 &amp;&amp; runs[n - 3].len &lt; runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }
        } else {
            None
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>é¦–å…ˆçœ‹ <code>collapse</code> å‡½æ•°ã€‚è¿™é‡Œç”¨ <code>collapse</code> åˆ¤æ–­æ˜¯å¦æœ‰èƒ½å¤Ÿåˆå¹¶çš„æ®µï¼Œå¦‚æœæœ‰ï¼Œåˆ™è¿”å›å…¶ä¸‹æ ‡ <code>r</code>ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™è¿”å› <code>None</code>ã€‚å…·ä½“åˆ¤æ–­çš„é€»è¾‘ç¨åè¯´æ˜ã€‚</p>
<p>æ­¥éª¤3ä¸­æ ¹æ® <code>collapse</code> å‡½æ•°çš„è¿”å›ç»“æœï¼Œä½¿ç”¨å½’å¹¶æ’åºåˆå¹¶ <code>runs[r]</code>å’Œ <code>runs[r + 1]</code>ï¼Œæˆ–è€…é‡å¤æ­¥éª¤ 1 å’Œæ­¥éª¤ 2ï¼Œç»§ç»­åœ¨æ ˆ <code>runs</code> ä¸­æ„å»ºæ–°çš„æ®µã€‚</p>
<p>åˆšåˆšçš„ä¾‹å­ä¸­ï¼Œæ ˆ <code>runs</code> ä¸­åªæœ‰ä¸€ä¸ªæ®µ <code>[0, 1, 3(1), 3(2), 7]</code>ï¼Œæ˜¾ç„¶ä¸èƒ½åˆå¹¶ï¼Œå› æ­¤é‡å¤æ­¥éª¤ 1 å’Œæ­¥éª¤ 2ï¼Œåœ¨ <code>runs</code> ä¸­æ·»åŠ ç¬¬äºŒä¸ªæ®µï¼Œä½¿å…¶å˜ä¸º <code>[[0, 1, 3(1), 3(2), 7], [4, 5, 6]]</code>(ç”¨ <code>[]</code> è¡¨ç¤ºä¸€ä¸ªæ®µ)ã€‚æ­¤æ—¶ <code>collapse</code> ä¼šè¿”å›ä¸‹æ ‡ <code>0</code>ï¼Œç„¶åä½¿ç”¨å½’å¹¶åˆå¹¶ <code>[0, 1, 3(1), 3(2), 7]</code> å’Œ <code>[4, 5, 6]</code>ã€‚å¾—åˆ°ç»“æœ <code>[0, 1, 3(1), 3(2), 4, 5, 6, 7]</code>ï¼Œå®Œæˆæ•´ä¸ªéå†ã€‚</p>
<h3 id="timsort-ç®—æ³•çš„-bug"><a class="header" href="#timsort-ç®—æ³•çš„-bug">Timsort ç®—æ³•çš„ bug</a></h3>
<p>Rust ä¸­çš„å®ç°å¹¶éé»˜è®¤çš„ Timsort çš„ç®—æ³•ï¼Œè¿™æ˜¯å› ä¸º Timsort ç®—æ³•å­˜åœ¨ bug(http://envisage-project.eu/timsort-specification-and-verification/)ã€‚Rust çš„å®ç°åœ¨ <code>collapse</code> è¿™ä¸ªå‡½æ•°åšäº†ä¿®æ”¹ã€‚</p>
<p>Timsort ç®—æ³•åœ¨ JDK1.7 ä¸­å¼•å…¥ Javaï¼Œä½†åœ¨ 1.8 ç‰ˆæœ¬ä»æœªä¿®å¤è¿™ä¸ª bugã€‚ æ¯”è¾ƒ Java JDK1.8ä¸­å¯¹åº”çš„å®ç°ã€‚Javaçš„å®ç°ä¸­åªæ¯”è¾ƒäº†æ ˆé¡¶3ä¸ªå…ƒç´ ï¼Œä½† Rust çš„ç°å®æ¯”è¾ƒäº†æ ˆé¡¶ 4 ä¸ªå…ƒç´ ã€‚</p>
<pre><code class="language-java">private void mergeCollapse() {
    while (stackSize &gt; 1) {
        int n = stackSize - 2;
        if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt;= runLen[n] + runLen[n + 1]) {
            if (runLen[n - 1] &lt; runLen[n + 1])
                n--;
            mergeAt(n);
        } else if (runLen[n] &lt;= runLen[n + 1]) {
            mergeAt(n);
        } else {
            break; // Invariant is established
        }
    }
}
</code></pre>
<p>å‡ºäºæ€§èƒ½åŸå› ï¼ŒTimsort è¦ç»´æŠ¤å°½å¯èƒ½å°‘çš„ runã€‚å› æ­¤åœ¨æ¯æ¬¡æ–°çš„ <code>run</code> å…¥æ ˆæ—¶ï¼Œä¼šè¿è¡Œ <code>mergeCollapse</code> å‡½æ•°åˆå¹¶æ ˆé¡¶ 3 ä¸ªå…ƒç´ ,åˆå› ä¸ºæ¯æ¬¡å…¥æ ˆéƒ½ä¼šæ‰§è¡Œï¼Œæ‰€ä»¥æ ˆä¸­æ‰€æœ‰ run çš„é•¿åº¦éƒ½æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š</p>
<ol>
<li>runLen[n - 2] &gt; runLen[n - 1] + runLen[n]</li>
<li>runLen[n - 1] &gt; runLen[n]</li>
</ol>
<p>å¦‚æœä¸æ»¡è¶³è§„åˆ™ 1ï¼Œåˆ™å°† run[n - 1] ä¸ run[n] å’Œ run[n - 2] è¾ƒçŸ­çš„åˆå¹¶ã€‚ä¾‹å¦‚ï¼Œruns ä¸­å­˜åœ¨ä¸¤ä¸ªé•¿åº¦åˆ†åˆ«ä¸º 12 å’Œ 7 çš„ runï¼Œæ­¤æ—¶å…¥æ ˆä¸€ä¸ªé•¿åº¦ä¸º 6 çš„runï¼Œåˆ™åˆå¹¶é•¿åº¦ä¸º 7 å’Œ 6 ä¸¤ä¸ª runï¼Œæ ˆå˜ä¸º [12, 13]ã€‚
å¦‚æœä¸æ»¡è¶³è§„åˆ™ 2ï¼Œåˆ™å°† run[n - 1] ä¸ run[n] åˆå¹¶ã€‚å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œç»§ç»­åˆå¹¶ 12 å’Œ 13ï¼Œæ­¤æ—¶ runs ä¸­ä»…å‰©ä¸€ä¸ªé•¿åº¦ä¸º 25 çš„ runã€‚å°±å¯ä»¥ç»§ç»­æ‰§è¡Œ Timsort ç®—æ³•çš„ç¬¬ä¸€æ­¥å’Œç¬¬äºŒæ­¥æ„é€ æ–°çš„ run æˆ–å®Œæˆæ’åºã€‚</p>
<p>ä½†é—®é¢˜åœ¨å“ªå‘¢ï¼Ÿè€ƒè™‘ä¸€ä¸ªä¾‹å­ï¼š</p>
<pre><code>120, 80, 25, 20, 30
</code></pre>
<p>å› ä¸º 25 &lt; 20 + 30ï¼Œ æ‰€ä»¥åˆå¹¶ä¸º</p>
<pre><code>120, 80, 45, 30
</code></pre>
<p>æ­¤æ—¶ï¼Œ <code>120, 80, 45</code> å·²ç»ä¸æ»¡è¶³è§„åˆ™ã€‚è¿™ä¸ªbugåœ¨<a href="http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it">è¿™é‡Œ</a>æœ‰æ›´ä¸ºè¯¦ç»†çš„æè¿°ä»¥åŠè§£å†³æ–¹æ³•ã€‚</p>
<h2 id="ä¸ç¨³å®šæ’åº-pdqsort"><a class="header" href="#ä¸ç¨³å®šæ’åº-pdqsort">ä¸ç¨³å®šæ’åºï¼š pdqsort</a></h2>
<p>todo</p>
<h2 id="ref"><a class="header" href="#ref">Ref</a></h2>
<ul>
<li>Timsort: <a href="https://github.com/python/cpython/blob/main/Objects/listsort.txt">https://github.com/python/cpython/blob/main/Objects/listsort.txt</a></li>
<li>OpenJDKâ€™s java.utils.Collection.sort() is broken: The good, the bad and the worst case: <a href="http://envisage-project.eu/timsort-specification-and-verification/">http://envisage-project.eu/timsort-specification-and-verification/</a></li>
<li>Proving that Androidâ€™s, Javaâ€™s and Pythonâ€™s sorting algorithm is broken (and showing how to fix it): <a href="http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/">http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/</a></li>
<li>Java bug track: <a href="https://bugs.openjdk.org/browse/JDK-8072909">https://bugs.openjdk.org/browse/JDK-8072909</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-compiler"><a class="header" href="#rust-compiler">Rust Compiler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invocation"><a class="header" href="#invocation">Invocation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexer"><a class="header" href="#lexer">Lexer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¯­æ³•åˆ†æ"><a class="header" href="#è¯­æ³•åˆ†æ">è¯­æ³•åˆ†æ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sema"><a class="header" href="#sema">Sema</a></h1>
<ul>
<li><a href="rustc/sema/../sema/lint/readme.html">Lint</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lint"><a class="header" href="#lint">Lint</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Lint is a kind of static analysis tool, which originated from the C language. Lint tools usually check potential problems and errors in code, including (but not limited to) programming style (indentation, blank lines, spaces), code quality (unused variables, missing documents), and error codes (division by zero, duplicate definitions, circular references). Generally speaking, in addition to identifying errors, lint tools also have some fix/refactor suggest and auto fix capabilities. Using lint tools in the project can effectively reduce errors and improve the project quality. In addition, for a programming language, the lint tool is usually a prerequisite for the development of other tools, such as the error prompt of IDE plug-ins(e.g., LSP) and the pipeline detection of CI.</p>
<h2 id="lint-vs-lintpass"><a class="header" href="#lint-vs-lintpass">Lint vs. LintPass</a></h2>
<h3 id="concepts"><a class="header" href="#concepts">Concepts</a></h3>
<p>There are two main structures about lint in Rustc, <code>Lint</code> and <code>LintPass</code>. First, we need to distinguish the concepts of Lint and LintPass. In many documents of Rustc, they are both referred to as 'Lint', which is easy to confuse. The difference between them is explained by rustc-dev-guide as follows:</p>
<blockquote>
<p>Lint declarations don't carry any &quot;state&quot; - they are merely global identifiers and descriptions of lints. We assert at runtime that they are not registered twice (by lint name).
Lint passes are the meat of any lint.</p>
</blockquote>
<p>In terms of definition, <code>Lint</code> is just a description of the lint check defined, such as name, level, description, code and other attributes. It doesn't carry any state of checking. Rustc checks the uniqueness of registered lints at runtime. <code>LintPass</code> is an implementation of <code>lint</code>, which contains the <code>check_*</code> methods that are called when checking.</p>
<p>In terms of code implementation, <code>Lint</code> is defined as a struct in Rust, and all lint definitions are an instance of this struct. And <code>LintPass</code> is a trait. The <code>Trait</code> is similar to the interface in Java/C++. Every definition of lintpass needs to implement the methods defined in the interface.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Specification of a single lint.
#[derive(Copy, Clone, Debug)]
pub struct Lint {
    pub name: &amp;'static str,
    /// Default level for the lint.
    pub default_level: Level,
    /// Description of the lint or the issue it detects.
    ///
    /// e.g., &quot;imports that are never used&quot;
    pub desc: &amp;'static str,
    ...
}

pub trait LintPass {
    fn name(&amp;self) -&gt; &amp;'static str;
}
<span class="boring">}
</span></code></pre></pre>
<p>It should be noted that although we just said that <code>trait</code> is similar to an interface and <code>Lint</code> is a struct, the relationship between <code>Lint</code> and <code>LintPass</code> is not a &quot;class&quot; and its &quot;methods&quot; in OO. Instead, declaring <code>LintPass</code> will generate a struct with the same name, this struct implements the trait, and the <code>get_lints()</code> method in this struct will generate the corresponding <code>Lint</code> definition.</p>
<p><img src="rustc/sema/lint/./images/lint_lintpass.jpeg" alt="lint vs. lintpass" /></p>
<p>This is also consistent with the description of the rustc-dev-guide:</p>
<blockquote>
<p>A lint might not have any lint pass that emits it, it could have many, or just one -- the compiler doesn't track whether a pass is in any way associated with a particular lint, and frequently lints are emitted as part of other work (e.g., type checking, etc.).</p>
</blockquote>
<h3 id="definition-of-lint-and-lintpass"><a class="header" href="#definition-of-lint-and-lintpass">Definition of Lint and LintPass</a></h3>
<p>Rustc provides macros for both Lint and LintPass to define their structure.
The macro <code>declare_lint</code> that defines Lint is simple, it can be found in <code>rustc_lint_defs::lib.rs</code>. The <code>declare_lint</code> macro parses the input arguments and produces a Lint struct named <code>$NAME</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! declare_lint {
    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr) =&gt; (
        $crate::declare_lint!(
            $(#[$attr])* $vis $NAME, $Level, $desc,
        );
    );
    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,
     $(@feature_gate = $gate:expr;)?
     $(@future_incompatible = FutureIncompatibleInfo { $($field:ident : $val:expr),* $(,)*  }; )?
     $($v:ident),*) =&gt; (
        $(#[$attr])*
        $vis static $NAME: &amp;$crate::Lint = &amp;$crate::Lint {
            name: stringify!($NAME),
            default_level: $crate::$Level,
            desc: $desc,
            edition_lint_opts: None,
            is_plugin: false,
            $($v: true,)*
            $(feature_gate: Some($gate),)*
            $(future_incompatible: Some($crate::FutureIncompatibleInfo {
                $($field: $val,)*
                ..$crate::FutureIncompatibleInfo::default_fields_for_macro()
            }),)*
            ..$crate::Lint::default_fields_for_macro()
        };
    );
    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,
     $lint_edition: expr =&gt; $edition_level: ident
    ) =&gt; (
        $(#[$attr])*
        $vis static $NAME: &amp;$crate::Lint = &amp;$crate::Lint {
            name: stringify!($NAME),
            default_level: $crate::$Level,
            desc: $desc,
            edition_lint_opts: Some(($lint_edition, $crate::Level::$edition_level)),
            report_in_external_macro: false,
            is_plugin: false,
        };
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>The definition of LintPass involves two macros:</p>
<ul>
<li>declare_lint_pass: Generate a struct named <code>$name</code> and call the macro <code>impl_lint_pass</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! declare_lint_pass {
    ($(#[$m:meta])* $name:ident =&gt; [$($lint:expr),* $(,)?]) =&gt; {
        $(#[$m])* #[derive(Copy, Clone)] pub struct $name;
        $crate::impl_lint_pass!($name =&gt; [$($lint),*]);
    };
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>impl_lint_pass: Implements the <code>fn name()</code> and <code>fn get_lints()</code> methods for the generated <code>LintPass</code> structure.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! impl_lint_pass {
    ($ty:ty =&gt; [$($lint:expr),* $(,)?]) =&gt; {
        impl $crate::LintPass for $ty {
            fn name(&amp;self) -&gt; &amp;'static str { stringify!($ty) }
        }
        impl $ty {
            pub fn get_lints() -&gt; $crate::LintArray { $crate::lint_array!($($lint),*) }
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="earlylintpass-and-latelintpass"><a class="header" href="#earlylintpass-and-latelintpass">EarlyLintPass and LateLintPass</a></h3>
<p>In the macro definition of <code>LintPass</code>, only the <code>fn name()</code> and <code>fn get_lints()</code> methods are defined, but the <code>check_*</code> functions for checking are not provided. This is because Rustc divides <code>LintPass</code> into two more specific categories: <code>EarlyLintPass</code> and <code>LateLintPass</code>. The main difference is whether the checked element has type information, i.e. is performed before or after the type checking. For example, <code>WhileTrue</code> checks for <code>while true{...}</code> in the code and prompts the user to use <code>loop{...}</code> instead it. This check does not require any type information and is therefore defined as an <code>EarlyLint</code> (<code>impl EarlyLintPass for WhileTrue</code> in the code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint! {
    WHILE_TRUE,
    Warn,
    &quot;suggest using `loop { }` instead of `while true { }`&quot;
}

declare_lint_pass!(WhileTrue =&gt; [WHILE_TRUE]);

impl EarlyLintPass for WhileTrue {
    fn check_expr(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, e: &amp;ast::Expr) {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rustc uses 3 macros to define <code>EarlyLintPass</code>:</p>
<ul>
<li>early_lint_methods: early_lint_methods defines the <code>check_*</code> functions that need to be implemented in <code>EarlyLintPass</code>, and passes these functions and the received parameters <code>$args</code> to the next macro.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! early_lint_methods {
    ($macro:path, $args:tt) =&gt; (
        $macro!($args, [
            fn check_param(a: &amp;ast::Param);
            fn check_ident(a: &amp;ast::Ident);
            fn check_crate(a: &amp;ast::Crate);
            fn check_crate_post(a: &amp;ast::Crate);
            ...
        ]);
    )
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>declare_early_lint_pass: Generate trait <code>EarlyLintPass</code> and call macro <code>expand_early_lint_pass_methods</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! declare_early_lint_pass {
    ([], [$($methods:tt)*]) =&gt; (
        pub trait EarlyLintPass: LintPass {
            expand_early_lint_pass_methods!(&amp;EarlyContext&lt;'_&gt;, [$($methods)*]);
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>expand_early_lint_pass_methods: Provides default implementations for <code>check_*</code> methods: nothing to do(<code>{}</code> in code).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! expand_early_lint_pass_methods {
    ($context:ty, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) =&gt; (
        $(#[inline(always)] fn $name(&amp;mut self, _: $context, $(_: $arg),*) {})*
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>The benefits are as follows:</p>
<ol>
<li>Because <code>LintPass</code> is a trait, every definition of <code>LintPass</code> needs to implement all of its methods. But early lint and late lint occur at different stages of compilation, and the input parameters are also different (AST and HIR). Therefore, the definition of LintPass contains only two general methods <code>fn name()</code> and <code>fn get_lints()</code>. The check methods are defined in the more specific <code>EarlyLintPass</code> and <code>LateLintPass</code>.</li>
<li>Likewise, for <code>EarlyLintPass</code>, every definition of lintpass must implement all of its methods. But not every lintpass needs to check all nodes of the AST. <code>expand_early_lint_pass_methods</code> provides default implementations for its methods. In this way, when defining a specific lintpass, you only need to pay attention to implementing its related check methods. For example, for the definition of <code>WhileTrue</code>, since <code>while true { }</code> only appears in the <code>ast::Expr</code> node, it only needs to implement the <code>check_expr</code> function. Calling the <code>WhileTrue</code> check function at any other node, such as call <code>WhileTrue.check_ident()</code> when checking an identifier node on the AST, will only execute an empty method as defined in the macro <code>expand_early_lint_pass_methods</code>.</li>
</ol>
<h3 id="meaning-of-pass"><a class="header" href="#meaning-of-pass">Meaning of pass</a></h3>
<p>In Rustc, in addition to <code>Lint</code> and <code>LintPass</code>, there are some <code>*Pass</code> naming, such as <code>Mir</code> and <code>MirPass</code>, the <code>rustc_passes</code> package, etc. The <strong>Compilers, Principles, Techniques, &amp; Tools</strong> has a corresponding explanation for Pass:</p>
<blockquote>
<p>1.2.8 Combine multiple steps into a pass
The previous discussion of steps was about the logical organization of a compiler. In a particular implementation, the activities of multiple steps can be combined into a pass. Each pass reads in an input file and produces an output file.</p>
</blockquote>
<p>In the macro <code>declare_lint_pass</code> that declares <code>LintPass</code>, its second parameter is a list, indicating that a lintpass can generate multiple lints. There are also some CombinedLintPass in Rustc that also aggregates all built-in lints into one lintpass. This is basically the same as the definition of &quot;pass&quot; in the Dragon Book: <code>LintPass</code> can combine multiple <code>Lint</code> checks, each LintPass reads an AST/HIR and produces a corresponding result.</p>
<h2 id="simple-design-of-linter"><a class="header" href="#simple-design-of-linter">Simple design of Linter</a></h2>
<p>In the definition of LintPass, a default implementation is provided for all <code>check_*</code> methods of each lintpass. So far, we can implement a simple Linter toolï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Linter { }
impl ast_visit::Visitor for Linter {
    fn visit_crate(a: ast:crate){
        for lintpass in lintpasses{
            lintpass.check_crate(a)
        }
        walk_crate();
    }
    fn visit_stmt(a: ast:stmt){
        for lintpass in lintpasses{
            lintpass.check_stmt(a)
        }
        walk_stmt();
    }
    ...
}

let linter = Linter::new();

for c in crates{
    linter.visit_crate(c);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Visitor</code> is a tool for traversing the AST. Here, the <code>visit_*</code> methods are implemented for Linter, and all lintpass <code>check_*</code> methods are called during traversal. <code>walk_*</code> will continue to call other <code>visit_*</code> methods to traverse its child nodes. So, for each crate, just call the <code>visit_crate()</code> function to traverse the AST and complete the lint check.</p>
<h2 id="combinedlintpass"><a class="header" href="#combinedlintpass">CombinedLintpass</a></h2>
<p>However, Rustc and Clippy provide more than 550 lint definitions. Considering the performance, it is obviously inappropriate to define a large number of lintpasses, register and call them separately. Rustc provides a better solution: since multiple lints can be organized into one lintpass, multiple lintpasses can also be combined into a CombinedLintPass.</p>
<blockquote>
<p><a href="https://rustc-dev-guide.rust-lang.org/diagnostics/lintstore.html#compiler-lint-passes-are-combined-into-one-pass">Compiler lint passes are combined into one pass</a>
Within the compiler, for performance reasons, we usually do not register dozens of lint passes. Instead, we have a single lint pass of each variety (e.g., BuiltinCombinedModuleLateLintPass) which will internally call all of the individual lint passes; this is because then we get the benefits of static over dynamic dispatch for each of the (often empty) trait methods.
Ideally, we'd not have to do this, since it adds to the complexity of understanding the code. However, with the current type-erased lint store approach, it is beneficial to do so for performance reasons.</p>
</blockquote>
<h3 id="builtincombinedearlylintpass"><a class="header" href="#builtincombinedearlylintpass">BuiltinCombinedEarlyLintPass</a></h3>
<p>Combinedlintpass is also divided into early and late. Take builtin's early lint as an example, <code>rustc_ lint::src::lib.rs</code> defines a <code>BuiltinCombinedEarlyLintPass</code> structure for these lintpasses.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);
<span class="boring">}
</span></code></pre></pre>
<p>Although this definition seems to have only one line, it summarizes 14 <code>LintPass</code> through the expansion of several macros, and each <code>LintPass</code> provides more than 50 'checks_*` method.  Let's explain these macros one by one.</p>
<h4 id="define-builtincombinedearlylintpass-by-macros"><a class="header" href="#define-builtincombinedearlylintpass-by-macros">Define BuiltinCombinedEarlyLintPass by macros</a></h4>
<ul>
<li>early_lint_passes</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! early_lint_passes {
    ($macro:path, $args:tt) =&gt; {
        $macro!(
            $args,
            [
                UnusedParens: UnusedParens,
                UnusedBraces: UnusedBraces,
                UnusedImportBraces: UnusedImportBraces,
                UnsafeCode: UnsafeCode,
                AnonymousParameters: AnonymousParameters,
                EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),
                NonCamelCaseTypes: NonCamelCaseTypes,
                DeprecatedAttr: DeprecatedAttr::new(),
                WhileTrue: WhileTrue,
                NonAsciiIdents: NonAsciiIdents,
                HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
                IncompleteFeatures: IncompleteFeatures,
                RedundantSemicolons: RedundantSemicolons,
                UnusedDocComment: UnusedDocComment,
            ]
        );
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The first is the macro <code>early_ lint_ passes</code>. The main function of this macro is to define all early lintpass. The left side of <code>:</code>is the identifier of lintpass, and the right side of <code>:</code> is the constructor of lintpass. Therefore, <code>ellipseinclusiverangepatterns::default()</code> and <code>deprecedattr::new()</code> are differnet from others. <code>early_ lint_ passes</code> passes the defined early lintpass to the next macro together with the second parameter.</p>
<p>Through this macro, the previous definition of <code>BuiltinCombinedEarlyLintPass</code> is expanded to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_combined_early_pass!([BuiltinCombinedEarlyLintPass], [
                UnusedParens: UnusedParens,
                UnusedBraces: UnusedBraces,
                UnusedImportBraces: UnusedImportBraces,
                UnsafeCode: UnsafeCode,
                AnonymousParameters: AnonymousParameters,
                EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),
                NonCamelCaseTypes: NonCamelCaseTypes,
                DeprecatedAttr: DeprecatedAttr::new(),
                WhileTrue: WhileTrue,
                NonAsciiIdents: NonAsciiIdents,
                HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
                IncompleteFeatures: IncompleteFeatures,
                RedundantSemicolons: RedundantSemicolons,
                UnusedDocComment: UnusedDocComment,
            ])
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>declare_combined_early_pass</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! declare_combined_early_pass {
    ([$name:ident], $passes:tt) =&gt; (
        early_lint_methods!(declare_combined_early_lint_pass, [pub $name, $passes]);
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>declare_combined_early_pass</code> receives the name (BuiltinCombinedEarlyLintPass) and passes from macro <code>early_lint_passes</code>, and continues to pass them to macro <code>early_lint_methods</code>.</p>
<p>Through this macro, the definition of <code>BuiltinCombinedEarlyLintPass</code> expand to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>early_lint_methods!(declare_combined_early_lint_pass, 
                    [pub BuiltinCombinedEarlyLintPass, 
                      [
                            UnusedParens: UnusedParens,
                            UnusedBraces: UnusedBraces,
                            UnusedImportBraces: UnusedImportBraces,
                            UnsafeCode: UnsafeCode,
                            AnonymousParameters: AnonymousParameters,
                            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),
                            NonCamelCaseTypes: NonCamelCaseTypes,
                            DeprecatedAttr: DeprecatedAttr::new(),
                            WhileTrue: WhileTrue,
                            NonAsciiIdents: NonAsciiIdents,
                            HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
                            IncompleteFeatures: IncompleteFeatures,
                            RedundantSemicolons: RedundantSemicolons,
                            UnusedDocComment: UnusedDocComment,
               ]
                    ]);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>early_lint_methods</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! early_lint_methods {
    ($macro:path, $args:tt) =&gt; (
        $macro!($args, [
            fn check_param(a: &amp;ast::Param);
            fn check_ident(a: &amp;ast::Ident);
            fn check_crate(a: &amp;ast::Crate);
            fn check_crate_post(a: &amp;ast::Crate);
            ...
        ]);
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>early_lint_methods</code> has been explained earlier. It defines the methods <code>check_*</code> which need to be implemented in the <code>EarlyLintPass</code>, and pass these methods and the parameter <code>$args</code> to the next macro. Because <code>BuiltinCombinedEarlyLintPass</code> is also a kind of early lint, it is also necessary to implement these methods.</p>
<p>Through this macro, the definition of 'BuiltinCombinedEarlyLintPass' expand to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_combined_early_lint_pass!(
    [pub BuiltinCombinedEarlyLintPass, 
        [
            UnusedParens: UnusedParens,
            UnusedBraces: UnusedBraces,
            UnusedImportBraces: UnusedImportBraces,
            UnsafeCode: UnsafeCode,
            AnonymousParameters: AnonymousParameters,
            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),
            NonCamelCaseTypes: NonCamelCaseTypes,
            DeprecatedAttr: DeprecatedAttr::new(),
            WhileTrue: WhileTrue,
            NonAsciiIdents: NonAsciiIdents,
            HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
            IncompleteFeatures: IncompleteFeatures,
            RedundantSemicolons: RedundantSemicolons,
            UnusedDocComment: UnusedDocComment,
        ]
    ],
    [
        fn check_param(a: &amp;ast::Param);
        fn check_ident(a: &amp;ast::Ident);
        fn check_crate(a: &amp;ast::Crate);
        fn check_crate_post(a: &amp;ast::Crate);
        ...
    ]
)
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>declare_combined_early_lint_pass</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! declare_combined_early_lint_pass {
    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], $methods:tt) =&gt; (
        #[allow(non_snake_case)]
        $v struct $name {
            $($passes: $passes,)*
        }
        impl $name {
            $v fn new() -&gt; Self {
                Self {
                    $($passes: $constructor,)*
                }
            }
            $v fn get_lints() -&gt; LintArray {
                let mut lints = Vec::new();
                $(lints.extend_from_slice(&amp;$passes::get_lints());)*
                lints
            }
        }
        impl EarlyLintPass for $name {
            expand_combined_early_lint_pass_methods!([$($passes),*], $methods);
        }
        #[allow(rustc::lint_pass_impl_without_macro)]
        impl LintPass for $name {
            fn name(&amp;self) -&gt; &amp;'static str {
                panic!()
            }
        }
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>declare_combined_early_lint_pass</code> is the main structure for generating <code>BuiltinCombinedEarlyLintPass</code>. It does the following works:</p>
<ul>
<li>Generate a struct named <code>BuiltinCombinedEarlyLintPass</code>, whose fields is the identifier provided by macro <code>early_lint_passes</code>.</li>
<li>Implement methods <code>fn new()</code> <code>fn name()</code> and <code>fn get_lints()</code>. The method <code>new()</code> uses constructor of lintpass provided by marco <code>early_lint_passes</code>.</li>
<li>Call the marco <code>expand_combined_early_lint_pass_methods</code> to implememt self <code>check_*</code> methods.</li>
</ul>
<p>Through this macro, the definition of <code>BuiltinCombinedEarlyLintPass</code> is changed to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BuiltinCombinedEarlyLintPass {
            UnusedParens: UnusedParens,
            UnusedBraces: UnusedBraces,
            UnusedImportBraces: UnusedImportBraces,
            UnsafeCode: UnsafeCode,
            AnonymousParameters: AnonymousParameters,
            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns,
            NonCamelCaseTypes: NonCamelCaseTypes,
            DeprecatedAttr: DeprecatedAttr,
            WhileTrue: WhileTrue,
            NonAsciiIdents: NonAsciiIdents,
            HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
            IncompleteFeatures: IncompleteFeatures,
            RedundantSemicolons: RedundantSemicolons,
            UnusedDocComment: UnusedDocComment,
}
impl BuiltinCombinedEarlyLintPass {
    pub fn new() -&gt; Self {
        Self {
            UnusedParens: UnusedParens,
            UnusedBraces: UnusedBraces,
            UnusedImportBraces: UnusedImportBraces,
            UnsafeCode: UnsafeCode,
            AnonymousParameters: AnonymousParameters,
            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns::default(),
            NonCamelCaseTypes: NonCamelCaseTypes,
            DeprecatedAttr: DeprecatedAttr::new(),
            WhileTrue: WhileTrue,
            NonAsciiIdents: NonAsciiIdents,
            HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,
            IncompleteFeatures: IncompleteFeatures,
            RedundantSemicolons: RedundantSemicolons,
            UnusedDocComment: UnusedDocComment,
        }
    }
    pub fn get_lints() -&gt; LintArray {
        let mut lints = Vec::new();
        lints.extend_from_slice(&amp;UnusedParens::get_lints());
        lints.extend_from_slice(&amp;UnusedBraces::get_lints());
        lints.extend_from_slice(&amp;UnusedImportBraces::get_lints());
        lints.extend_from_slice(&amp;UnsafeCode::get_lints());
        lints.extend_from_slice(&amp;AnonymousParameters::get_lints());
        lints.extend_from_slice(&amp;EllipsisInclusiveRangePatterns::get_lints());
        lints.extend_from_slice(&amp;NonCamelCaseTypes::get_lints());
        lints.extend_from_slice(&amp;DeprecatedAttr::get_lints());
        lints.extend_from_slice(&amp;WhileTrue::get_lints());
        lints.extend_from_slice(&amp;NonAsciiIdents::get_lints());
        lints.extend_from_slice(&amp;HiddenUnicodeCodepoints::get_lints());
        lints.extend_from_slice(&amp;IncompleteFeatures::get_lints());
        lints.extend_from_slice(&amp;RedundantSemicolons::get_lints());
        lints.extend_from_slice(&amp;UnusedDocComment::get_lints());
        
        lints
    }
}
impl EarlyLintPass for BuiltinCombinedEarlyLintPass {
    expand_combined_early_lint_pass_methods!([$($passes),*], $methods);
}
#[allow(rustc::lint_pass_impl_without_macro)]
impl LintPass for BuiltinCombinedEarlyLintPass {
    fn name(&amp;self) -&gt; &amp;'static str {
        panic!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>expand_combined_early_lint_pass_methods</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! expand_combined_early_lint_pass_methods {
    ($passes:tt, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) =&gt; (
        $(fn $name(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, $($param: $arg),*) {
            expand_combined_early_lint_pass_method!($passes, self, $name, (context, $($param),*));
        })*
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>Marco <code>expand_combined_early_lint_pass_methods</code> explands all methods defined in <code>early_lint_methods</code>.</p>
<p>Through this macro, the definition of <code>BuiltinCombinedEarlyLintPass</code> is changed to(ignore other definitions):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for BuiltinCombinedEarlyLintPass {
    fn check_param(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Param) {
        expand_combined_early_lint_pass_method!($passes, self, $name, (context, $($param),*));
    }
    fn check_ident(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Ident) {
        expand_combined_early_lint_pass_method!($passes, self, $name, (context, $($param),*));
    }
    fn check_crate(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Crate) {
        expand_combined_early_lint_pass_method!($passes, self, $name, (context, $($param),*));
    }
    ...
    
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>expand_combined_early_lint_pass_method</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! expand_combined_early_lint_pass_method {
    ([$($passes:ident),*], $self: ident, $name: ident, $params:tt) =&gt; ({
        $($self.$passes.$name $params;)*
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>expand_combined_early_lint_pass_method</code> call <code>check_*</code> methods defined in each <code>LintPass</code>.</p>
<p>Through this macro, the definition of <code>BuiltinCombinedEarlyLintPass</code> is changed to(ignore other definitions):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for BuiltinCombinedEarlyLintPass {
    fn check_param(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Param) {
        self.UnusedParens.check_param(context, a);
        self.UnusedBraces.check_param(context, a);
        self.UnusedImportBraces.check_param(context, a);
        ...
    }
    fn check_ident(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Ident) {
        self.UnusedParens.check_ident(context, a);
        self.UnusedBraces.check_ident(context, a);
        self.UnusedImportBraces.check_ident(context, a);
        ...
    }
    fn check_crate(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Crate) {
        self.UnusedParens.check_crate(context, a);
        self.UnusedBraces.check_crate(context, a);
        self.UnusedImportBraces.check_crate(context, a);
        ...
    }
    ...
    
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="definition-of-builtincombinedearlylintpass"><a class="header" href="#definition-of-builtincombinedearlylintpass">Definition of BuiltinCombinedEarlyLintPass</a></h4>
<p>Through the expansion of the above macro, <code>BuiltinCombinedEarlyLintPass</code> is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BuiltinCombinedEarlyLintPass {
    UnusedParens: UnusedParens,
    UnusedBraces: UnusedBraces,
    ...
}

impl BuiltinCombinedEarlyLintPass{
    pub fn new() -&gt; Self {
        UnusedParens: UnusedParens,
        UnusedBraces: UnusedBraces,
        ...
    }
    
    pub fn get_lints() -&gt; LintArray {
        let mut lints = Vec::new();
        lints.extend_from_slice(&amp;UnusedParens::get_lints());
        lints.extend_from_slice(&amp;UnusedBraces::get_lints());
        ...
        lints
    }
}

impl EarlyLintPass for BuiltinCombinedEarlyLintPass {
    fn check_crates(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: &amp;ast::Crate){
        self.UnusedParens.check_crates (context, a);
        self.UnusedBraces.check_crates (context, a);
        ...
    }
    fn check_ident(&amp;mut self, context: &amp;EarlyContext&lt;'_&gt;, a: Ident){
        self.UnusedParens.check_ident (context, a);
        self.UnusedBraces.check_ident (context, a);
        ...
    }
    .. 
}
<span class="boring">}
</span></code></pre></pre>
<p>Through this definition, we can use the <code>check_*</code> method of <code>BuiltinCombinedEarlyLintPass</code> to run multiple lintpasses when traversing the AST.</p>
<h2 id="optimize-the-design-of-linter"><a class="header" href="#optimize-the-design-of-linter">Optimize the design of Linter</a></h2>
<p>Based on CombinedLintPassï¼Œwe can optimize the design of Linter:
<img src="rustc/sema/lint/./images/linter.jpg" alt="Linter" /></p>
<p>Here, we use <code>check_*</code> of CombinedLintPass to run lint check when traversing the AST.</p>
<p>Although the effect is the same as before, because of the macro, all <code>check_*</code> methods and lintpass to be executed are collected into a structure, which is easier to manage. Similarly, because combinedlintpass actually calls the check methods of each lintpass, although the call may be as complex as the following figure, most of the check methods defined in lintpass are empty checks(just a <code>{}</code>) generated by macros, there will be no performance loss.</p>
<p><img src="rustc/sema/lint/./images/combinedlintpass.jpg" alt="combinedlintpass" /></p>
<h2 id="how-lint-works-in-rustc"><a class="header" href="#how-lint-works-in-rustc">How Lint Works in Rustc</a></h2>
<p>Finally, let's see how lint works in Rustc.</p>
<h3 id="lints-execution-phase-in-rustc"><a class="header" href="#lints-execution-phase-in-rustc">Lint's execution phase in Rustc</a></h3>
<p>Rustc's design is similar to classic compilers, including lexical analysis, syntax analysis, semantic analysis, IR generation, IR optimization, code generation and other processes. In addition, some special processes, such as borrowing check, have been added to the compiler for Rust feature. Correspondingly, the intermediate representation of the code in the whole compilation process also has some extensions. I found the explanation of IR in the <a href="https://rustc-dev-guide.rust-lang.org/overview.html#intermediate-representations">rust-dev-guide</a>ï¼š</p>
<ul>
<li>Token stream: the lexer produces a stream of tokens directly from the source code. This stream of tokens is easier for the parser to deal with than raw text.</li>
<li>Abstract Syntax Tree (AST): the abstract syntax tree is built from the stream of tokens produced by the lexer. It represents pretty much exactly what the user wrote. It helps to do some syntactic sanity checking (e.g. checking that a type is expected where the user wrote one).</li>
<li>High-level IR (HIR): This is a sort of desugared AST. It's still close to what the user wrote syntactically, but it includes some implicit things such as some elided lifetimes, etc. This IR is amenable to type checking.</li>
<li>Typed HIR (THIR): This is an intermediate between HIR and MIR, and used to be called High-level Abstract IR (HAIR). It is like the HIR but it is fully typed and a bit more desugared (e.g. method calls and implicit dereferences are made fully explicit). Moreover, it is easier to lower to MIR from THIR than from HIR.</li>
<li>Middle-level IR (MIR): This IR is basically a Control-Flow Graph (CFG). A CFG is a type of diagram that shows the basic blocks of a program and how control flow can go between them. Likewise, MIR also has a bunch of basic blocks with simple typed statements inside them (e.g. assignment, simple computations, etc) and control flow edges to other basic blocks (e.g., calls, dropping values). MIR is used for borrow checking and other important dataflow-based checks, such as checking for uninitialized values. It is also used for a series of optimizations and for constant evaluation (via MIRI). Because MIR is still generic, we can do a lot of analyses here more efficiently than after monomorphization.</li>
<li>LLVM IR: This is the standard form of all input to the LLVM compiler. LLVM IR is a sort of typed assembly language with lots of annotations. It's a standard format that is used by all compilers that use LLVM (e.g. the clang C compiler also outputs LLVM IR). LLVM IR is designed to be easy for other compilers to emit and also rich enough for LLVM to run a bunch of optimizations on it.</li>
</ul>
<p>The above conversion process of Rust's IR also reflects the whole compilation process of Rust, which is summarized in one figure:</p>
<p><img src="rustc/sema/lint/images/complication_process.jpg" alt="Complication process" />
`rustc_ driver::lib. Rs' controls each stage of the compilation process:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_compiler(...) -&gt; interface::Result&lt;()&gt; {
    ...
    interface::run_compiler(config, |compiler| {
        let linker = compiler.enter(|queries| {
            ...
            queries.parse()?;   // lexer parse
            ...
            queries.expansion()?; // resolver
            ...
            queries.prepare_outputs()?;
            ...
            queries.global_ctxt()?; // ast -&gt; hir
            ...
            queries.ongoing_codegen()?;
            ...
            }
}
<span class="boring">}
</span></code></pre></pre>
<p>As described previously, lint is divided into early and late, which are executed in phases of AST -&gt; HIR and HIR -&gt; THIR respectively. Here we will also take the example of <code>WhileTrue</code> to see the whole process of Lint from definition to registration and execution. Meanwhile, <code>WhileTrue</code> is one of built-in early lint and is included in <code>BuiltinCombinedEarlyLintPass</code>.</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>Definitions of <code>WhileTrue</code>'s lint and lintpass are defined in <code>rustc_lint/src/builtin.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_lint! {
    /// The `while_true` lint detects `while true { }`.
    ///
    /// ### Example
    ///
    /// ```rust,no_run
    /// while true {
    ///
    /// }
    /// ```
    ///
    /// {{produces}}
    ///
    /// ### Explanation
    ///
    /// `while true` should be replaced with `loop`. A `loop` expression is
    /// the preferred way to write an infinite loop because it more directly
    /// expresses the intent of the loop.
    WHILE_TRUE,
    Warn,
    &quot;suggest using `loop { }` instead of `while true { }`&quot;
}

declare_lint_pass!(WhileTrue =&gt; [WHILE_TRUE]);

impl EarlyLintPass for WhileTrue {
    fn check_expr(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, e: &amp;ast::Expr) {
      ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As described previously,</p>
<ol>
<li>Macro <code>declare_lint</code> declare a lint: <code>WHILE_TRUE</code></li>
<li>Macro <code>declare_lint_pass</code> declare a lint: <code>WhileTrue</code></li>
<li>Implement the <code>check_*</code> methods defined in <code>EarlyLintPass</code> for<code>WHILE_TRUE</code>. Because this lintpass only checks the expr node, it only needs to implement <code>check_ expr()</code> method.</li>
</ol>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<p><code>Whiletrue</code> does not require separate registration and execution. Its checking method is expanded into <code>BuiltinCombinedEarlyLintPass</code> by macro. The <code>BuiltinCombinedEarlyLintPass</code> register and execute in the method <code>queries.expansion()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expansion(
    &amp;self,
) -&gt; Result&lt;&amp;Query&lt;(Rc&lt;ast::Crate&gt;, Rc&lt;RefCell&lt;BoxedResolver&gt;&gt;, Lrc&lt;LintStore&gt;)&gt;&gt; {
    tracing::trace!(&quot;expansion&quot;);
    self.expansion.compute(|| {
        let crate_name = self.crate_name()?.peek().clone();
        // register
        let (krate, lint_store) = self.register_plugins()?.take(); 
        let _timer = self.session().timer(&quot;configure_and_expand&quot;);
        let sess = self.session();
        let mut resolver = passes::create_resolver(
            sess.clone(),
            self.codegen_backend().metadata_loader(),
            &amp;krate,
            &amp;crate_name,
        );
        let krate = resolver.access(|resolver| {
            // execute
            passes::configure_and_expand(sess, &amp;lint_store, krate, &amp;crate_name, resolver)
        })?;
        Ok((Rc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>The registration process will generate a defined lint structure and add it to the <a href="https://rustc-dev-guide.rust-lang.org/diagnostics/lintstore.html">LintStore</a>. Lint is divided into four categories: pre-expansion, early, late and late-module. Although lintpasses are executed at different stages in the compilation process, registration occurs at the same time.</p>
<p>The function call of lint registration process is as follows:</p>
<ul>
<li>rustc_driver::lib::run_compiler()</li>
<li>rustc_interface::queries::Queries.expansion()</li>
<li>rustc_interface::queries::Queries.register_plugins()</li>
<li>rustc_lint::lib::new_lint_store()</li>
<li>rustc_lint::lib::register_builtins()</li>
</ul>
<p>Here, the default compilation process will execute the statement in the <code>else</code> branch, <code>BuiltinCombinedEarlyLintPass::get_lints()</code> will generate <code>WhileTrue</code> and added it to LintStore.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if no_interleave_lints {
    pre_expansion_lint_passes!(register_passes, register_pre_expansion_pass);
    early_lint_passes!(register_passes, register_early_pass);
    late_lint_passes!(register_passes, register_late_pass);
    late_lint_mod_passes!(register_passes, register_late_mod_pass);
} else {
    store.register_lints(&amp;BuiltinCombinedPreExpansionLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedEarlyLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedModuleLateLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedLateLintPass::get_lints());
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>The execution of different lintpass occurs at different stages of the compilation process. The function call of the <code>BuiltinCombinedEarlyLintPass</code> execution process are as follows:</p>
<ul>
<li>rustc_driver::lib::run_compiler()</li>
<li>rustc_interface::queries::Queries.expansion()</li>
<li>rustc_interface::passes::configure_and_expand()</li>
<li>rustc_lint::early::check_ast_node()</li>
<li>rustc_lint::early::early_lint_node()</li>
</ul>
<p>é¦–å…ˆï¼Œåœ¨ configure_and_expand() å‡½æ•°ä¸­ï¼Œæ‰§è¡Œäº† pre-expansion å’Œ early ä¸¤ç§ lintpassã€‚æ³¨å†Œæ—¶ä½¿ç”¨äº† BuiltinCombinedEarlyLintPass::get_lints() æ–¹æ³•ç”Ÿæˆ lintsï¼Œè€Œè¿™é‡Œç”¨ BuiltinCombinedEarlyLintPass::new() æ–¹æ³•ç”Ÿæˆäº† lintpassã€‚</p>
<p>First, in function <code>configure_ and_expand()</code>, pre-expansion and early lintpass are executed. Lints which generated by <code>BuiltinCombinedEarlyLintPass::get_lints()</code> were used for registration, and here, and lintpasses which generated by BuiltinCombinedEarlyLintPass::new() were used for execution.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn configure_and_expand(
    sess: &amp;Session,
    lint_store: &amp;LintStore,
    mut krate: ast::Crate,
    crate_name: &amp;str,
    resolver: &amp;mut Resolver&lt;'_&gt;,
) -&gt; Result&lt;ast::Crate&gt; {
    pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &amp;krate, crate_name);
    ...
    sess.time(&quot;early_lint_checks&quot;, || {
        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));
        rustc_lint::check_ast_node(
            sess,
            false,
            lint_store,
            resolver.registered_tools(),
            lint_buffer,
            rustc_lint::BuiltinCombinedEarlyLintPass::new(),
            &amp;krate,
        )
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>Lint execution finally occurs in function <code>rustc_lint::early::early_lint_node()</code>. Compare <code>early_ lint_ Node()</code> and the pseudo-code at the end of the <code>CombinedLintPass</code> section:</p>
<p><img src="rustc/sema/lint/images/early_lint_node.jpg" alt="early_lint_nodeä¸CombinedLintPass" /></p>
<p>They have the following relationship:</p>
<ul>
<li>The parameter <code>pass</code>  is the <code>BuiltinCombinedEarlyLintPass</code> created in <code>configure_and_expand()</code>. It corresponds to <code>combinedlintpassã€‚</code>.</li>
<li><code>EarlyContextAndPass</code> combined <code>pass</code> and <code>context</code>, and implement the <code>visitor</code>. It corresponds to <code>Linter</code>.</li>
<li><code>check_node.check(cx)</code> call <code>cx.pass.check_crate()</code> and execute lint check. According to the definition of <code>BuiltinCombinedEarlyLintPass</code>, this method will call all <code>check_crate()</code> defined in builtin early lint, and run <code>ast_visit::walk_crate()</code> to traverses sub-node. It corresponds to <code>visit_crate()</code>.</li>
</ul>
<h3 id="no_interleave_lints"><a class="header" href="#no_interleave_lints">no_interleave_lints</a></h3>
<p>Although Rustc combines lintpass into combinedlintpass in consideration of performance, it provides some compilation parameters to configure lint. Among them, the parameter <code>no_interleave_lints</code> is used in the registration and execution of lint. This parameter defaults to false, indicating whether to execute each lint separately. By modifying this parameter during compilation, each lint can be registered separately and lintpass can be executed separately. This design provides better flexibility and customization (for example, you can benchmark each lint separately).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if no_interleave_lints {
    pre_expansion_lint_passes!(register_passes, register_pre_expansion_pass);
    early_lint_passes!(register_passes, register_early_pass);
    late_lint_passes!(register_passes, register_late_pass);
    late_lint_mod_passes!(register_passes, register_late_mod_pass);
} else {
    store.register_lints(&amp;BuiltinCombinedPreExpansionLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedEarlyLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedModuleLateLintPass::get_lints());
    store.register_lints(&amp;BuiltinCombinedLateLintPass::get_lints());
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn check_ast_node&lt;'a&gt;(...) {
    if sess.opts.debugging_opts.no_interleave_lints {
        for (i, pass) in passes.iter_mut().enumerate() {
            buffered =
                sess.prof.extra_verbose_generic_activity(&quot;run_lint&quot;, pass.name()).run(|| {
                    early_lint_node(
                        sess,
                        !pre_expansion &amp;&amp; i == 0,
                        lint_store,
                        registered_tools,
                        buffered,
                        EarlyLintPassObjects { lints: slice::from_mut(pass) },
                        check_node,
                    )
                });
        }
    } else {
        buffered = early_lint_node(
            sess,
            !pre_expansion,
            lint_store,
            registered_tools,
            buffered,
            builtin_lints,
            check_node,
        );
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>So far, we have analyzed the complete process of a lint in Rustc, including defining a lint, implementing the corresponding lintpass, registration and execution. We can also use these macros to define new lint and lintpass (e.g., extension in Clippy. It works in a similar way). Of course, lint in Rustc is far more than that. I only share a small part of it that I can understand and I have learned. I hope it can help you.</p>
<p>In addition to this, we have practiced part of this content in Project <a href="https://github.com/KusionStack/KCLVM">KCLVM</a>. You can find more detailed design and implementation of lint in <a href="https://github.com/KusionStack/KCLVM/issues/109">issue</a> and <a href="https://github.com/KusionStack/KCLVM/pull/160">PR</a>, including the definition of <code>visitor</code>, lint, lintpass, combinedlintpass, and execution of lint in resolver. Welcome for your comments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codegen"><a class="header" href="#codegen">Codegen</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-çš„é”™è¯¯ä¿¡æ¯è¾“å‡ºåŸç†æ¦‚è¿°"><a class="header" href="#rust-çš„é”™è¯¯ä¿¡æ¯è¾“å‡ºåŸç†æ¦‚è¿°">Rust çš„é”™è¯¯ä¿¡æ¯è¾“å‡ºåŸç†æ¦‚è¿°</a></h1>
<h2 id="1-èƒŒæ™¯"><a class="header" href="#1-èƒŒæ™¯">1. èƒŒæ™¯</a></h2>
<p>æœ€è¿‘åœ¨å‚ä¸ <a href="https://link.zhihu.com/?target=https%3A//github.com/KusionStack/kusion">KusionStack</a> å†…ç½®çš„é¢†åŸŸè¯­è¨€ â€”â€” <a href="https://link.zhihu.com/?target=https%3A//github.com/KusionStack/kclvm">KCL é…ç½®è¯­è¨€ç¼–è¯‘å™¨</a> çš„å¼€å‘ï¼Œéœ€è¦å¼€å‘ç¼–è¯‘å™¨çš„é”™è¯¯å¤„ç†æ¨¡å—ï¼Œç”±äº KCL ä½¿ç”¨ Rust å¼€å‘çš„ï¼Œå› æ­¤æ‰“ç®—æ¥å­¦å­¦ Rust è¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å—æ˜¯æ€ä¹ˆåšçš„ã€‚</p>
<h2 id="2-ä»‹ç»"><a class="header" href="#2-ä»‹ç»">2. ä»‹ç»</a></h2>
<p>å•çº¯ä» Rustc æºç çš„ç›®å½•ç»“æ„ä¸­çœ‹ï¼ŒRustc ä¸­å…³äºé”™è¯¯å¤„ç†çš„éƒ¨åˆ†ä¸»è¦é›†ä¸­åœ¨ rustc_errors ã€rustc_error_codes å’Œ rustc_error_message ä¸‰ä¸ªç›®å½•ä¸‹ï¼Œä½†æ˜¯åœ¨çœ‹æºç çš„è¿‡ç¨‹ä¸­æˆ‘å‘ç°ç”±äº Rustc ä»£ç é‡å¤§ï¼Œå¹¶ä¸”é”™è¯¯å¤„ç†æ¨¡å—æ¶‰åŠåˆ°å¾ˆå¤šå…¶ä»–çš„æ¨¡å—ï¼Œå•çº¯çš„çœ‹è¿™ä¸‰ä¸ªç›®å½•ä¸‹çš„ä»£ç å¾ˆå®¹æ˜“çœ‹æ™•ï¼Œå‰–æèµ·æ¥ä¹Ÿæ¯”è¾ƒå›°éš¾ã€‚å› æ­¤ï¼Œæˆ‘æ‰“ç®—å°†è¿™éƒ¨åˆ†çš„çš„æºç å‰–ææ‹†åˆ†æˆå‡ ä¸ªéƒ¨åˆ†ï¼Œè¿™ç¯‡æ–‡ç« ä¸»è¦ç»“åˆ<a href="https://rustc-dev-guide.rust-lang.org/"> Rustc çš„å®˜æ–¹æ–‡æ¡£</a>å’Œ<a href="https://github.com/rust-lang/rust"> Rustc æºç </a>è¿›è¡Œç»“æ„çš„æ¢³ç†ã€‚</p>
<p>å› æ­¤æœ¬æ–‡çš„æ ¸å¿ƒæ€è·¯åªæ˜¯å¯¹é”™è¯¯å¤„ç†éƒ¨åˆ†çš„ç»“æ„è¿›è¡Œæ¢³ç†ï¼Œç›®æ ‡å°±æ˜¯æ¢³ç†ä¸€ä¸‹åœ¨ Rustc å¯¹ Rust ç¨‹åºè¿›è¡Œè§£æçš„è¿‡ç¨‹ä¸­ï¼Œé”™è¯¯æ˜¯å¦‚ä½•ä»åˆ†æè¿‡ç¨‹ä¸€æ­¥ä¸€æ­¥ä¼ é€’åˆ°ç»ˆç«¯è¾“å‡ºæˆè¯Šæ–­ä¿¡æ¯çš„ã€‚å¯¹äºä¸€äº›å¤æ‚ä¸”ä¸é”™è¯¯è¯Šæ–­ä¿¡æ¯è¾“å‡ºæ— å…³çš„å†…å®¹ï¼Œæˆ‘ä»¬å…ˆæš‚ä¸”ç•¥è¿‡ä¸åšæ·±ç©¶ã€‚ç•™ä¸ªå‘åé¢å†å¡«ï¼Œå…ˆæŠŠç»“æ„æ¢³ç†æ¸…æ¥šï¼Œä¹Ÿæœ‰åŠ©äºæˆ‘ä»¬åç»­ä¸€æ­¥ä¸€æ­¥çš„å¯¹æºç è¿›è¡Œæ›´åŠ æ·±å…¥æ¸…æ™°çš„å‰–æï¼Œé˜²æ­¢æˆ‘ä»¬åœ¨ Rustc å¤§é‡çš„æºç ä¸­è¿·è·¯ã€‚å¹¶ä¸”ä¸ºäº†èƒ½æ›´åŠ æ¸…æ™°çš„çœ‹ä»£ç çš„ç»“æ„ï¼Œæœ¬æ–‡å¯¹ä½¿ç”¨çš„ä»£ç ç‰‡æ®µåšäº†å¤„ç†ï¼Œå»æ‰äº†ç”Ÿå‘½å‘¨æœŸç­‰ä¸ä»£ç æ‰§è¡Œé€»è¾‘æ— å…³çš„éƒ¨åˆ†ã€‚</p>
<h2 id="3-è¯Šæ–­ä¿¡æ¯é•¿å•¥æ ·"><a class="header" href="#3-è¯Šæ–­ä¿¡æ¯é•¿å•¥æ ·">3. è¯Šæ–­ä¿¡æ¯é•¿å•¥æ ·ï¼Ÿ</a></h2>
<p>é¦–å…ˆï¼Œçœ‹æºç ä¹‹å‰ï¼Œå…ˆçœ‹çœ‹ Rust çš„è¯Šæ–­ä¿¡æ¯çš„æ ¼å¼ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>
<p><img src="rustc/general/errors/./images/error-01.png" alt="" /></p>
<p>æ ¹æ® Rustc æ–‡æ¡£ä¸­çš„æè¿°ï¼Œä¸Šè¿°ä¿¡æ¯å¯ä»¥åˆ†ä¸ºä¸‹é¢5ä¸ªéƒ¨åˆ†ï¼Œ</p>
<ul>
<li>
<p>Level ç­‰çº§ (é”™è¯¯ï¼Œè­¦å‘Šç­‰ç­‰)ï¼Œè¿™éƒ¨åˆ†ä¸»è¦ç”¨æ¥è¯´æ˜å½“å‰æ¶ˆæ¯çš„ä¸¥é‡ç¨‹åº¦ã€‚</p>
</li>
<li>
<p>Code ä»£ç æˆ–è€…ç¿»è¯‘æˆç¼–å·æ›´å¥½ä¸€äº› (ä¾‹å¦‚ï¼šå¯¹äºâ€œé”™è¯¯çš„ç±»å‹â€è¿™ç§è¯Šæ–­ä¿¡æ¯ï¼Œå®ƒå¯¹åº”çš„ç¼–å·æ˜¯E0308)ï¼Œè¿™ä¸ªç¼–å·æ˜¯ä¸€ä¸ªç´¢å¼•ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡è¿™ä¸ªç´¢å¼•æ‰¾åˆ°å½“å‰é”™è¯¯æ›´åŠ å®Œæ•´çš„æè¿°ä¿¡æ¯ã€‚é€šè¿‡ lint åˆ›å»ºçš„è¯Šæ–­ä¿¡æ¯æ²¡æœ‰è¿™ä¸ªç¼–å·ã€‚<br />
<strong>æ³¨ï¼šæˆ‘åé¢åˆæŸ¥äº†ä¸€ä¸‹ï¼Œrustc å®˜æ–¹æŠŠ Code ç§°ä½œ <a href="https://doc.rust-lang.org/error-index.html">Rust Compiler Error Index</a>ã€‚</strong></p>
</li>
<li>
<p>Message æ¶ˆæ¯ï¼Œæè¿°å½“å‰å‘ç”Ÿçš„é—®é¢˜çš„ä¸»è¦å†…å®¹ï¼Œè¿™ä¸ªæ¶ˆæ¯çš„å†…å®¹åº”è¯¥æ˜¯é€šç”¨çš„ç‹¬ç«‹çš„ï¼Œå³ä½¿æ²¡æœ‰å…¶ä»–å†…å®¹åªçœ‹è¿™ä¸€æ¡ä¿¡æ¯çš„è¯ï¼Œä¹Ÿèƒ½æœ‰æ‰€å¸®åŠ©ã€‚</p>
</li>
<li>
<p>Diagnostic Window è¯Šæ–­çª—å£ï¼Œä¸»è¦è´Ÿè´£å±•ç¤ºå‡ºç°é—®é¢˜çš„ä»£ç ä¸Šä¸‹æ–‡ç›¸å…³çš„ä¿¡æ¯ã€‚</p>
</li>
<li>
<p>Sub-diagnostic å­è¯Šæ–­ä¿¡æ¯ï¼Œä»»ä½•é”™è¯¯éƒ½æœ‰å¾ˆå¤šçš„å­è¯Šæ–­ä¿¡æ¯å¹¶ä¸”ä»–ä»¬çœ‹èµ·æ¥éƒ½å’Œè¯Šæ–­ä¿¡æ¯çš„ä¸»éƒ¨åˆ†ç›¸ä¼¼ã€‚</p>
</li>
</ul>
<h2 id="4-è¯Šæ–­ä¿¡æ¯ä»å“ªæ¥"><a class="header" href="#4-è¯Šæ–­ä¿¡æ¯ä»å“ªæ¥">4. è¯Šæ–­ä¿¡æ¯ä»å“ªæ¥ï¼Ÿ</a></h2>
<p>åœ¨äº†è§£äº† Rustc è¯Šæ–­ä¿¡æ¯ä¹‹åï¼Œæˆ‘ä»¬çœ‹ä¸‹ Rustc æ˜¯å¦‚ä½•æ„é€ è¿™æ ·çš„è¯Šæ–­ä¿¡æ¯çš„ã€‚åœ¨è¿™éƒ¨åˆ† Rustc å®˜æ–¹æä¾›äº†ä¸¤ç§æ–¹å¼ï¼Œ</p>
<ol>
<li>å®ç° rustc_sessions æä¾›çš„ traitã€‚</li>
<li>ç”¨ rustc_macros ä¸­ä¸ºè¾“å‡ºè¯Šæ–­ä¿¡æ¯å‡†å¤‡çš„å±æ€§å®ï¼Œè‡ªåŠ¨å®ç° rustc_sessions æä¾›çš„ traitã€‚</li>
</ol>
<p>ç›´æ¥çœ‹ä¸Šé¢è¿™ä¸¤ç‚¹ä¸å¤ªå¥½ç†è§£ï¼Œä¸»è¦çš„æµç¨‹å¯ä»¥å‚è€ƒä¸‹é¢è¿™å¼ å›¾ï¼Œ</p>
<p><img src="rustc/general/errors/./images/error-02.png" alt="" /></p>
<p>å…¶ä¸­ï¼Œé»„è‰²éƒ¨åˆ†è¡¨ç¤ºåœ¨ Rustc çš„ä¸åŒæ¨¡å—ä¸­ï¼Œå®šä¹‰å„è‡ªçš„é”™è¯¯/è­¦å‘Šç­‰å¼‚å¸¸ç±»å‹çš„ç»“æ„ä½“ Struct  (<strong>æ³¨ï¼šæšä¸¾ä¹Ÿå¯ä»¥ï¼Œæœ¬æ–‡æ˜¯ä¸€ä¸ªæ¦‚è¿°ï¼Œä¸ºäº†æ–¹ä¾¿æè¿°æ‰€ä»¥ä¸‹é¢å°±åªåˆ—Structäº†</strong>)ã€‚ç»¿è‰²éƒ¨åˆ†è¡¨ç¤ºåœ¨Rustcçš„é”™è¯¯å¤„ç†æ¨¡å—æä¾›äº†ä¸€ä¸ª trait SessionDiagnosticã€‚ä¸åŒæ¨¡å—å†…éƒ¨å®šä¹‰çš„ Struct å®ç°è¿™ä¸ª trait SessionDiagnosticã€‚trait SessionDiagnostic çš„å…·ä½“å®ç°å°±æ˜¯å°† Struct ä¸­è¾“å‡ºè¯Šæ–­ä¿¡æ¯éœ€è¦çš„å†…å®¹æŠ½å–å‡ºæ¥å°è£…å¥½ï¼Œè¿”å›ç»™ Rustc çš„é”™è¯¯å¤„ç†æ¨¡å—ç”¨æ¥è¾“å‡ºã€‚</p>
<p>è¿™å°±æ˜¯ä¸Šé¢æåˆ°çš„å®ç°é”™è¯¯æ¨¡å—æä¾›çš„ traitã€‚è¿™ä¸ª trait SessionDiagnostic çš„æºç å¦‚ä¸‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rustc/compiler/rustc_session/src/session.rs
pub trait SessionDiagnostic
&lt;T: EmissionGuarantee = ErrorGuaranteed&gt; 
{
    fn into_diagnostic(
        self, 
        sess: &amp; ParseSess
    ) -&gt; DiagnosticBuilder&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>ä»¥ Rustc æ–‡æ¡£ä¸­ç»™å‡ºçš„é”™è¯¯ç»“æ„ä¸ºä¾‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FieldAlreadyDeclared {
    pub field_name: Ident,
    pub span: Span,
    pub prev_span: Span,
}
<span class="boring">}
</span></code></pre></pre>
<p>æŒ‰ç…§ Rustc çš„å®˜æ–¹æè¿°ï¼Œè¦æƒ³è¾“å‡º struct FieldAlreadyDeclared å¯¹åº”çš„é”™è¯¯ä¿¡æ¯ï¼Œå°±è¦å®ç° trait SessionDiagnosticã€‚Rustc çš„æºç å†…éƒ¨å®šä¹‰çš„é”™è¯¯ç»“æ„ç›®å‰å®Œå…¨é‡‡ç”¨ç¬¬äºŒç§æ–¹å¼ã€‚</p>
<p>åœ¨ Rustc æä¾›çš„å®˜æ–¹æ–‡æ¡£ä¸Šï¼Œæä¾›äº† trait SessionDiagnostic çš„å…·ä½“å®ç°ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SessionDiagnostic for FieldAlreadyDeclared {
    fn into_diagnostic(self, sess: Session) -&gt; DiagnosticBuilder {
        let mut diag = sess.struct_err(...);
        diag.set_span(self.span);
        diag.span_label(...);
        ... 
        diag
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>ä¸Šé¢ä»£ç å±•ç¤ºäº†å¦‚ä½•ä¸º Struct FieldAlreadyDeclared å®ç° trait SessionDiagnosticï¼Œå…·ä½“çš„ä»£ç ç»†èŠ‚çœ‹ä¸æ‡‚ä¹Ÿä¸ç”¨æ€¥ï¼Œè¿™é‡Œåªåšä¸€ä¸ªå±•ç¤ºï¼Œä»£ç çš„ç»†èŠ‚ä¸æ˜¯æˆ‘ä»¬æœ¬æ–‡çš„ä¸»é¢˜ï¼Œè¿‡æ—©çš„æ·±å…¥ä»£ç ç»†èŠ‚å®¹æ˜“è¿·è·¯ï¼Œåªè¦çŸ¥é“è¿™éƒ¨åˆ†ä»£ç ä» Struct FieldAlreadyDeclared æŠ½å–å‡ºäº†è¾“å‡ºè¯Šæ–­ä¿¡æ¯éœ€è¦çš„å†…å®¹ï¼Œå¹¶å°è£…åˆ°äº† DiagnosticBuilder ä¸­è¿”å›ã€‚</p>
<p>é‚£ä¹ˆæ€ä¹ˆç†è§£ç¬¬äºŒç§æ–¹å¼å‘¢ï¼Ÿä»¥ä¸Šé¢çš„ä»£ç ä¸ºä¾‹ï¼Œå®ç° trait SessionDiagnostic ä¸»è¦æ˜¯å°† Struct FieldAlreadyDeclared ä¸­éœ€è¦è¾“å‡ºåˆ°è¯Šæ–­ä¿¡æ¯ä¸­çš„å†…å®¹ï¼ŒæŠ½å–å‡ºæ¥ï¼Œå¡«å……åˆ° DiagnosticBuilder ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹å…¶å®å°±æ˜¯åœ¨æ¬ç –ï¼Œå°†ç»„æˆè¯Šæ–­ä¿¡æ¯çš„ç –å—ä» Struct FieldAlreadyDeclared æ¬è¿åˆ° DiagnosticBuilder ä¸­ï¼Œå› æ­¤ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥è‡ªåŠ¨åŒ–ï¼Œå½“æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„é”™è¯¯ Struct çš„æ—¶å€™ï¼Œç –å—ä¸éœ€è¦æˆ‘ä»¬è‡ªå·±æ¬ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç¨‹åºå¸®æˆ‘ä»¬æ¬ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨å®šä¹‰ Struct çš„æ—¶å€™æ ‡æ³¨å‡ºæ¥å“ªäº›ç –éœ€è¦æ¬å°±å¯ä»¥äº†ã€‚</p>
<p>æ‰€ä»¥ï¼ŒRustc å†…éƒ¨é€šè¿‡å±æ€§å®çš„æ–¹å¼å†™å¥½äº†æ¬ç –çš„ç¨‹åºï¼Œè¿™ä¸ªæ¬ç –ç¨‹åºä¸ºæˆ‘ä»¬æä¾›äº†ä¸€äº›æ³¨è§£ï¼Œåœ¨å®šä¹‰æ–°çš„é”™è¯¯ Struct æ—¶ï¼Œåªéœ€è¦é€šè¿‡æ³¨è§£æ ‡æ³¨å‡ºå“ªäº›ç –è¦æ¬ï¼ŒRustc å†…éƒ¨çš„å±æ€§å®å°±ä¼šä¸ºæˆ‘ä»¬è‡ªåŠ¨å®ç° trait SessionDiagnosticã€‚åŒæ ·æ˜¯ Struct FieldAlreadyDeclaredï¼Œä½¿ç”¨ç¬¬äºŒç§æ–¹å¼çš„ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SessionDiagnostic)]
#[diag(typeck::field_already_declared, code = &quot;E0124&quot;)]
pub struct FieldAlreadyDeclared {
    pub field_name: Ident,
    #[primary_span]
    #[label]
    pub span: Span,
    #[label(typeck::previous_decl_label)]
    pub prev_span: Span,
}
<span class="boring">}
</span></code></pre></pre>
<p>å…¶ä¸­ï¼Œé€šè¿‡æ³¨è§£ #[derive(SessionDiagnostic)] ä½¿ç”¨ rustc_sessions å†…éƒ¨å®ç°çš„å±æ€§å®ï¼Œé€šè¿‡æ³¨è§£[diag(typeck::field_already_declared, code = &quot;E0124&quot;)] è¯´æ˜å½“å‰è¯Šæ–­ä¿¡æ¯è¾“å‡ºçš„æ–‡æœ¬ä¿¡æ¯ä¸å‰é¢æåˆ°çš„å½“å‰è¯Šæ–­ä¿¡æ¯çš„ç¼–å·ï¼Œæœ€åé€šè¿‡æ³¨è§£ #[primary_span], #[label] å’Œ #[label(typeck::previous_decl_label)] æ³¨è§£æ ‡æ³¨äº†å‡ºç°é—®é¢˜çš„ä»£ç ä¸Šä¸‹æ–‡ç›¸å…³çš„ä¿¡æ¯ã€‚</p>
<p>å®šä¹‰äº†å¸¦æœ‰æ³¨è§£çš„ Struct æˆ–è€…ä¸º Struct å®ç°äº† trait SessionDiagnostic åï¼Œæ¥ä¸‹æ¥è¦åšä»€ä¹ˆï¼ŸRustc æ–‡æ¡£æ˜¯è¿™ä¹ˆè¯´çš„ã€‚</p>
<p><strong>Now that we've defined our diagnostic, how do we use it? It's quite straightforward, just create an instance of the struct and pass it to emit_err (or emit_warning).</strong></p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å®šä¹‰äº†æˆ‘ä»¬çš„è¯Šæ–­ä¿¡æ¯ï¼Œé‚£æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨å®ƒå‘¢ï¼Ÿè¿™éå¸¸ç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ›å»ºä¸€ä¸ªç»“æ„ä½“çš„å®ä¾‹ï¼Œå¹¶å°†å®ƒä¼ é€’ç»™ emit_err() æˆ–è€… emit_warning() æ–¹æ³•å°±å¯ä»¥äº†ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tcx.sess.emit_err(FieldAlreadyDeclared {
    field_name: f.ident,
    span: f.span,
    prev_span,
});
<span class="boring">}
</span></code></pre></pre>
<p>ä¸å¤ªæ˜ç™½ï¼Œä½†æ˜¯å¾—åˆ°äº†ä¸€ä¸ªå…³é”®æ–¹æ³• emit_err() ï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•å°†é”™è¯¯çš„è¯Šæ–­ä¿¡æ¯è¾“å‡ºåˆ°ç»ˆç«¯ï¼Œé‚£å°±åœ¨æºç é‡Œå…¨å±€æœç´¢ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ï¼š</p>
<p><img src="rustc/general/errors/./images/error-03.png" alt="" /></p>
<p>æ‰¾åˆ°äº†è¿™ä¸ªæ–¹æ³•çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// è¿™ä¸ªæ–¹æ³•åœ¨ Struct Session ä¸­ã€‚
impl Session{
    pub fn emit_err(
        &amp;self, 
        err: impl SessionDiagnostic
    ) -&gt; ErrorGuaranteed {
        self.parse_sess.emit_err(err)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>æˆ‘ä»¬é¡ºç€æ–¹æ³•çš„è°ƒç”¨é“¾è·¯è¿ç»­ç‚¹è¿›å»çœ‹çœ‹ï¼Œ</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// self.parse_sess.emit_err(err)
impl ParseSess{
    pub fn emit_err(
        &amp;self, 
        err: impl SessionDiagnostic
    ) -&gt; ErrorGuaranteed {
        self.create_err(err).emit()
    }
}

// self.create_err(err)
impl ParseSess{
    pub fn create_err(
        &amp;'a self,
        err: impl SessionDiagnostic,
    ) -&gt; DiagnosticBuilder&lt;ErrorGuaranteed&gt; {
        err.into_diagnostic(self)
    }
}

// self.create_err(err).emit()
impl DiagnosticBuilder {
    pub fn emit(&amp;mut self) -&gt; G {
        ......
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>çœ‹ä»£ç å¥½åƒæ˜ç™½äº†ï¼ŒæŠŠä¸Šé¢é”™è¯¯å¤„ç†è¿‡ç¨‹çš„å›¾ç»†åŒ–ä¸€ä¸‹ï¼š</p>
<p><img src="rustc/general/errors/./images/error-05.png" alt="" /></p>
<p>å¦‚å›¾æ‰€ç¤ºï¼Œæˆ‘åœ¨å›¾çš„å³é¢å¢åŠ äº†ä¸€äº›ä¸œè¥¿ï¼Œé»„è‰²çš„éƒ¨åˆ†æ²¡æœ‰å¤ªå¤§çš„å˜åŒ–ï¼ŒRustc å…¶ä»–çš„æ¨¡å—å®šä¹‰é”™è¯¯çš„ Structï¼Œç»¿è‰²çš„éƒ¨åˆ†å¢åŠ äº†ä¸€äº›å†…å®¹ï¼Œç»†åŒ–äº† trait SessionDiagnostic çš„ä¸»è¦å®ç°ï¼Œæ ¹æ®é»„è‰²çš„ Struct æä¾›çš„å†…å®¹ç”Ÿæˆè“è‰²çš„ DiagnosticBuilderã€‚ç”Ÿæˆçš„ DiagnosticBuilder ä¸­ï¼Œå†…ç½® emit() æ–¹æ³•ç”¨æ¥å°†è¯Šæ–­ä¿¡æ¯è¾“å‡ºåˆ°ç»ˆç«¯ï¼Œè¿™ä¸ª emit() æ–¹æ³•æœ€åä¼šåœ¨ Session ä¸­è¢«è°ƒç”¨ã€‚</p>
<p>åœ¨ rustc ä¸­é€šè¿‡ Struct Session è°ƒç”¨ç”Ÿæˆçš„ DiagnosticBuilder æ¥è¾“å‡ºè¯Šæ–­ä¿¡æ¯ï¼Œå…·ä½“çš„è°ƒç”¨è¿‡ç¨‹å¦‚ä¸Šå›¾å³ä¾§æ‰€ç¤ºï¼ŒStruct Session å†…ç½®äº† Struct ParseSess ,è¿™é‡ŒåŒ…äº†ä¸¤å±‚ emit_err() æ–¹æ³•ï¼Œå¹¶ä¸”åœ¨æ–¹æ³• ParseSess.emit_err() ä¸­ï¼Œè°ƒç”¨äº† ParseSess.create_err() æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ¥å— trait SessionDiagnostic çš„å®ç°ï¼Œå¹¶è°ƒç”¨ trait SessionDiagnostic æä¾›çš„ into_diagnostic() æ–¹æ³•è·å– DiagnosticBuilder å®ä¾‹ï¼Œéšåè°ƒç”¨ DiagnosticBuilder å†…ç½®çš„ emit() æ–¹æ³•å°†è¯Šæ–­ä¿¡æ¯è¾“å‡ºåˆ°ç»ˆç«¯ã€‚</p>
<p>çœ‹åˆ°è¿™é‡Œï¼Œé—®é¢˜åˆæ¥äº†ï¼ŒRustc é€šè¿‡ Session æ¥æ”¶ DiagnosticBuilder è¾“å‡ºè¯Šæ–­ä¿¡æ¯ï¼Œè¿™ä¸ª Session æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ª Session æ˜¯å¦‚ä½•ä¸ Rustc å…¶ä»–æ¨¡å—è”åŠ¨çš„å‘¢ï¼Ÿæˆ–è€…è¯´è¿™ä¸ª Session æ˜¯æ€ä¹ˆè¢«è°ƒç”¨çš„å‘¢ï¼Ÿ</p>
<p>å…³äº Session æ˜¯ä»€ä¹ˆï¼Œè¿™ä¸æ˜¯æœ¬æ–‡çš„é‡ç‚¹ï¼Œä¸ºäº†é˜²æ­¢è¿·è·¯ï¼Œè¿™é‡Œå…ˆåˆ¨ä¸ªå‘ï¼Œåç»­çš„æ–‡ç« ä¸­çœ‹çœ‹ Session æ˜¯ä»€ä¹ˆï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ Session æ˜¯æ€ä¹ˆè¢«è°ƒç”¨æ¥å¤„ç†é”™è¯¯çš„ã€‚æˆ‘ä»¬åœ¨å…¨å±€æœç´¢ä¸€ä¸‹ sess.emit_err() è¿™ä¸ªå…³é”®å­—ï¼Œçœ‹çœ‹ rustc æ˜¯å¦‚ä½•é€šè¿‡ Session è¾“å‡ºè¯Šæ–­ä¿¡æ¯çš„ã€‚</p>
<p>å¯ä»¥çœ‹åˆ°ï¼Œåœ¨Rustcä¸­å¾ˆå¤šåœ°æ–¹éƒ½é€šè¿‡ Session è¾“å‡ºé”™è¯¯ä¿¡æ¯ã€‚</p>
<p><img src="rustc/general/errors/./images/error-04.png" alt="" /></p>
<p>æˆ‘çœ‹äº†ä¸€ä¸‹ï¼ŒæŒ‘äº†å‡ ä¸ªå…¶ä¸­æ¯”è¾ƒå…¸å‹ï¼Œè§åçŸ¥æ„çš„åœ°æ–¹ã€‚é¦–å…ˆæ˜¯åœ¨ Ructc çš„è¯­æ³•è§£æå™¨ rustc_parse ä¸­ï¼Œåœ¨è¿›è¡Œè¯­æ³•åˆ†æçš„è¿‡ç¨‹ä¸­é‡åˆ°é”™è¯¯ï¼Œä¼šé€šè¿‡ sess.emit_err() æ–¹æ³•è¾“å‡ºé”™è¯¯çš„è¯Šæ–­ä¿¡æ¯ã€‚</p>
<p><img src="rustc/general/errors/./images/error-06.png" alt="" /></p>
<p>ç„¶åï¼Œåœ¨ rustc çš„ç±»å‹æ£€æŸ¥å™¨ TypeChecker ä¸­ï¼Œæ‰€æœ‰æƒå€Ÿç”¨æ£€æŸ¥ rustc_borrowck éƒ¨åˆ†å’Œç±»å‹æ£€æŸ¥éƒ¨åˆ† rustc_typeck åœ¨æ£€æŸ¥åˆ°é”™è¯¯æ—¶ä¼šé€šè¿‡ sess.emit_err() æ–¹æ³•è¾“å‡ºé”™è¯¯çš„è¯Šæ–­ä¿¡æ¯ã€‚ä¸ rustc_parse ä¸åŒçš„æ˜¯ TypeChecker å¹¶ä¸ç›´æ¥å°† Session å®ä¾‹ä½œä¸ºç»“æ„ä½“æˆå‘˜è€Œæ˜¯é€šè¿‡ä¸€ä¸ªè·å–ä¸Šä¸‹æ–‡çš„æ–¹æ³• tcx() è·å– Session å®ä¾‹ã€‚</p>
<p><img src="rustc/general/errors/./images/error-07.png" alt="" />
<img src="rustc/general/errors/./images/error-08.png" alt="" /></p>
<p>è¿™ä¸ªä¸Šä¸‹æ–‡æ–¹æ³• tcx() çš„ç»†èŠ‚ä»¥åŠä¸Šä¸‹æ–‡çš„ç»“æ„ä¹Ÿæ˜¯æš‚ä¸æ·±ç©¶ï¼Œç›®å‰æˆ‘ä»¬åªéœ€è¦çŸ¥é“ TypeChecker ä¹Ÿæ˜¯é€šè¿‡ Session è¾“å‡ºè¯Šæ–­ä¿¡æ¯çš„å°±å¤Ÿäº†ã€‚ç„¶åï¼Œæˆ‘ä»¬æ¥æµ…çœ‹ä¸€ä¸‹ä»–ä»¬æ˜¯å¦‚ä½•å€ŸåŠ© Session è¾“å‡ºé”™è¯¯çš„ä¿¡æ¯çš„ã€‚</p>
<p>é¦–å…ˆï¼Œçœ‹çœ‹ rustc_parse ä¸­å…³äº Session çš„éƒ¨åˆ†ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Parser {
    pub sess: &amp; ParseSess,
	......
}

// åœ¨ Parser è§£æ Rust è¯­è¨€çš„æ—¶å€™,ä¼šè°ƒç”¨emit_erræ–¹æ³•è¾“å‡ºè¯Šæ–­ä¿¡æ¯ã€‚
self.sess.emit_err(...)
<span class="boring">}
</span></code></pre></pre>
<p>è§åçŸ¥æ„ç»™æˆ‘å¸¦æ¥äº†ä¸€ç‚¹è¯¯åˆ¤ï¼Œ Parser å†…ç½®çš„æ˜¯ ParseSess è€Œä¸æ˜¯ Sessionã€‚æ‰€ä»¥ï¼Œå¯ä»¥å€ŸåŠ©ä¸Šé¢é‚£ä¸ªå›¾çš„ç»“æ„ï¼Œç»™ Parser é”™è¯¯å¤„ç†çš„å±€éƒ¨ä¹Ÿå•ç‹¬ç”»ä¸€å¼ å›¾ã€‚</p>
<p><img src="rustc/general/errors/./images/error-09.png" alt="" /></p>
<p>ä¹‹å‰çš„å›¾ä¸­å·²ç»å±•ç¤ºäº†å†…éƒ¨çš„ç»†èŠ‚ï¼Œè¿™é‡Œå°±ä¸å±•ç¤ºäº†ï¼Œè¿™é‡Œåªå±•ç¤º trait SessionDiagnostic å’Œ Parser ä¹‹é—´çš„å…³ç³»ï¼Œ(<strong>æ³¨ï¼šä¸Šå›¾ä¸­çš„ Parse() æ–¹æ³•æ˜¯æˆ‘èµ·çš„åå­—ï¼ŒæŒ‡çš„æ˜¯ Rustcä¸­ å¯¹ Rust ç¨‹åºè¯­æ³•åˆ†æçš„è¿‡ç¨‹ï¼Œåœ¨ Rustc æºç¨‹åºä¸­è¿™ä¸ªæ–¹æ³•å¹¶ä¸ä¸€å®šå­˜åœ¨ï¼Œå…·ä½“ç”¨çš„æ˜¯ä»€ä¹ˆæ–¹æ³•ä¸æ˜¯æœ¬æ–‡çš„é‡ç‚¹ï¼Œä½†æ˜¯åªè¦æ˜¯ç¼–è¯‘å™¨å°±ä¸€å®šæœ‰ parse è¿‡ç¨‹ï¼Œåœ¨ä¸åŒçš„ç¼–è¯‘å™¨ä¸­ parse è¿‡ç¨‹çš„åå­—å¯èƒ½ä¸åŒã€‚</strong>)</p>
<p>å¦‚å›¾æ‰€ç¤ºï¼Œåœ¨å¯¹ Rust ç¨‹åºè¿›è¡Œè¯­æ³•åˆ†æçš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‡ºç°é”™è¯¯ï¼Œå°±å®ä¾‹åŒ–ä¸€ä¸ªå®ç°äº† trait SessionDiagnostic çš„é”™è¯¯ Struct ç»“æ„ï¼Œå¹¶æŠŠå®ƒæŠ›ç»™ Parser å†…ç½®çš„ ParseSess ä¸­çš„ emit_err() æ–¹æ³•å°†è¯Šæ–­ä¿¡æ¯è¾“å‡ºã€‚</p>
<p>ç„¶åï¼Œå†çœ‹çœ‹ rustc_borrowck å’Œ rustc_typeckï¼Œä»è°ƒç”¨æ–¹å¼æ¥çœ‹ï¼Œä»–ä»¬ä¸æ˜¯ç›´æ¥å†…ç½® Session çš„ï¼Œä»–ä»¬åº”è¯¥æ˜¯å†…ç½®äº†ä¸€ä¸ªä¸Šä¸‹æ–‡ç›¸å…³çš„ç»“æ„ï¼Œç„¶åé‚£ä¸ªä¸Šä¸‹æ–‡ç›¸å…³çš„ç»“æ„ä¸­åŒ…å« Session ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.tcx().sess.emit_err(MoveUnsized { ty, span });
<span class="boring">}
</span></code></pre></pre>
<p>ç‚¹è¿› self çœ‹ä¸€ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªç±»å‹æ£€æŸ¥å™¨ TypeChecker ï¼Œæ‰¾åˆ°ä¸Šä¸‹æ–‡ç»“æ„å¹¶ç‚¹è¿›å»æ·±åº¦ä¼˜å…ˆçš„æœç´¢ Session æˆ–è€… ParseSess ç»“æ„ï¼Œä¸ºäº†é˜²æ­¢å¤§å®¶çœ‹çš„æ—¶å€™è¿·è·¯ï¼Œæœç´¢è¿‡ç¨‹å°±ä¸å†™äº†ï¼Œè¿™é‡Œç›´æ¥å±•ç¤ºæœç´¢ç»“æœã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeChecker {
    infcx: &amp; InferCtxt,
    ......
}

pub struct InferCtxt {
    pub tcx: TyCtxt,
    ......
}

pub struct TyCtxt {
    gcx: &amp; GlobalCtxt,
}


pub struct GlobalCtxt {
    pub sess: &amp; Session, // Session åœ¨è¿™é‡Œ
    ....
}
<span class="boring">}
</span></code></pre></pre>
<p>è—çš„å¤Ÿæ·±çš„ï¼Œä¸è¿‡å¥½åœ¨æˆ‘ä»¬è¿˜æ˜¯æŠŠå®ƒæŒ–äº†å‡ºæ¥ï¼Œç›®å‰èšç„¦äºé”™è¯¯å¤„ç†ï¼Œæ‰€ä»¥æš‚æ—¶ä¸ç”¨å…³å¿ƒè¿™äº›ä¸Šä¸‹æ–‡ç»“æ„ (XXXCtxt) éƒ½æ˜¯ä»€ä¹ˆæ„æ€ã€‚</p>
<p><img src="rustc/general/errors/./images/error-10.png" alt="" /></p>
<p>å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œä¸ Parser çš„éƒ¨åˆ†åŒç†ï¼Œty_check() æ˜¯æˆ‘è‡ªå·±å†™çš„æ–¹æ³•ï¼Œä»£æŒ‡ TypeChecker å¯¹ Rust ç¨‹åºè¿›è¡Œç±»å‹æ£€æŸ¥çš„è¿‡ç¨‹ï¼Œç›®å‰èšç„¦äºé”™è¯¯å¤„ç†ï¼Œæ‰€ä»¥ InferCtxtï¼ŒTyCtxt å’Œ GlobalCtxt ç­‰ä¸Šä¸‹æ–‡ç»“æ„æˆ‘å°±ç¼©å†™ä¸º XXXCtx äº†ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªè¿‡ç¨‹å’Œ Parser é”™è¯¯å¤„ç†çš„è¿‡ç¨‹æ˜¯ä¸€æ ·çš„ï¼Œåœ¨ç±»å‹æ£€æŸ¥çš„è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œå°±å®ä¾‹åŒ–ä¸€ä¸ªå®ç°äº† trait SessionDiagnostic çš„ç»“æ„ï¼Œå¹¶æŠŠå®ƒæŠ›ç»™ TypeChecker å†…ç½®çš„å„ç§ä¸Šä¸‹æ–‡ä¸­å†…ç½®çš„ Session ä¸­çš„ emit_err() æ–¹æ³•å°†è¯Šæ–­ä¿¡æ¯è¾“å‡ºã€‚</p>
<p>çœ‹åˆ°è¿™é‡Œï¼Œå‹åŠ›æ¥åˆ°äº† Session å’Œ ParseSess è¿™è¾¹ï¼Œæ—¢ç„¶å¤§å®¶éƒ½æŠŠé”™è¯¯æŠ›ç»™ä»–ï¼Œé‚£å°±æ¥çœ‹çœ‹å®ƒé‡Œé¢å¹²äº†å•¥ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Session {
    pub parse_sess: ParseSess,
	......
}

pub struct ParseSess {
    pub span_diagnostic: Handler,
	......
}
<span class="boring">}
</span></code></pre></pre>
<p>çœ‹ä¸å¤ªæ˜ç™½ï¼Œå†æŠŠä¹‹å‰çš„ä»£ç æ‹¿æ¥çœ‹çœ‹</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// self.parse_sess.emit_err(err)
impl ParseSess{
    pub fn emit_err(
        &amp; self, 
        err: impl SessionDiagnostic
    ) -&gt; ErrorGuaranteed {
        self.create_err(err).emit()
    }
}

// è¿™ä¸ªæ–¹æ³•æ˜¯ self.create_err(err)
impl ParseSess{
    pub fn create_err(
        &amp; self,
        err: impl SessionDiagnostic,
    ) -&gt; DiagnosticBuilder&lt;ErrorGuaranteed&gt; {
        err.into_diagnostic(self)
    }
}

// è¿™ä¸ªæ–¹æ³•æ˜¯ self.create_err(err).emit()
impl DiagnosticBuilder {
    pub fn emit(&amp;mut self) -&gt; G {
        ...... /// çœ‹æ¥ï¼Œæ˜¯æ—¶å€™æŠŠè¿™é‡Œçœç•¥çš„ä»£ç å±•å¼€äº†...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>å±•å¼€ä¸Šè¿°ç¬¬21è¡Œçš„ä»£ç ï¼Œçœ‹åˆ°è¿™æ˜¯ä¸€ä¸ª trait çš„æŠ½è±¡æ¥å£ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;G: EmissionGuarantee&gt; DiagnosticBuilder&lt;G&gt; {
    pub fn emit(&amp;mut self) -&gt; G {
        // çœç•¥çš„ä»£ç 
        G::diagnostic_builder_emit_producing_guarantee(self)
}

// çœç•¥çš„ä»£ç æ˜¯ä¸€ä¸ªtraitçš„æŠ½è±¡æ¥å£ã€‚
pub trait EmissionGuarantee: Sized {
    fn diagnostic_builder_emit_producing_guarantee(
        db: &amp;mut DiagnosticBuilder
    ) -&gt; Self;
	...
}
<span class="boring">}
</span></code></pre></pre>
<p>ä¸ºäº†é˜²æ­¢è¿·è·¯ï¼Œå…ˆä¸æ·±ç©¶ EmissionGuarantee æ˜¯åšä»€ä¹ˆçš„ï¼Œåªå…³æ³¨ä»–æä¾›çš„è¾“å‡ºè¯Šæ–­ä¿¡æ¯åˆ°ç»ˆç«¯çš„åŠŸèƒ½å°±å¥½äº†ã€‚
ç„¶åï¼Œæˆ‘ä»¬åœ¨å…¨å±€æœç´¢ EmissionGuaranteeï¼Œæ‰¾ä¸€ä¸ª EmissionGuarantee çš„å®ç°ï¼Œçœ‹çœ‹ä»–æ˜¯å¦‚ä½•è¾“å‡ºä¿¡æ¯çš„ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EmissionGuarantee for ErrorGuaranteed {
    fn diagnostic_builder_emit_producing_guarantee(
        db: &amp;mut DiagnosticBuilder&lt;Self&gt;
    ) -&gt; Self {
        match db.inner.state {
            DiagnosticBuilderState::Emittable(handler) =&gt; {
                ...
                let guar = handler.emit_diagnostic(&amp;mut db.inner.diagnostic);
            	...
            }
            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation =&gt; {
                ......
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>çœ‹åˆ°ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘è§‰å¾—å‹åŠ›æ¥åˆ°äº† DiagnosticBuilder è¿™è¾¹ï¼Œæ¥éƒ½æ¥äº†ï¼Œå¾—çœ‹çœ‹ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// match db.inner.state

pub struct DiagnosticBuilder&lt;G: EmissionGuarantee&gt; {
    inner: DiagnosticBuilderInner,
    ...
}

struct DiagnosticBuilderInner {
    state: DiagnosticBuilderState,
    diagnostic: Box&lt;Diagnostic&gt;,
}

// match db.inner.state
enum DiagnosticBuilderState {
    Emittable(&amp; Handler),
    AlreadyEmittedOrDuringCancellation,
}
<span class="boring">}
</span></code></pre></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œæœ€åæ˜¯é€šè¿‡ DiagnosticBuilderState ä¸­çš„ Handler è¾“å‡ºå¾—è¯Šæ–­ä¿¡æ¯ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A handler deals with errors and other compiler output.
/// Certain errors (fatal, bug, unimpl) may cause immediate exit,
/// others log errors for later reporting.
pub struct Handler {
    flags: HandlerFlags,
    inner: Lock&lt;HandlerInner&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>åˆ° Handler è¿™é‡Œï¼Œçœ‹çœ‹æ³¨é‡Šï¼Œæˆ‘è§‰å¾—å¯ä»¥äº†ï¼Œæˆ‘ä»¬çŸ¥é“äº†æ‰€æœ‰é”™è¯¯çš„è¯Šæ–­ä¿¡æ¯ï¼Œæœ€åéƒ½é€šè¿‡ Handler è¾“å‡ºåˆ°ç»ˆç«¯ï¼Œåˆ°è¿™é‡Œï¼Œå¯ä»¥å†æŠŠä¸Šé¢çš„å›¾ç»†åŒ–ä¸€ä¸‹ï¼š</p>
<p><img src="rustc/general/errors/./images/error-11.png" alt="" /></p>
<p>å¦‚å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬åœ¨å›¾ä¸­å°† DiagnosticBuilder å†…éƒ¨çš„ä¸€ç‚¹ç‚¹ç»†èŠ‚ç”»è¿›å»äº†ï¼Œå…ˆä¸è€ƒè™‘ EmissionGuaranteeã€‚ DiagnosticBuilder ä¸­åŒ…å«è¾“å‡ºè¯Šæ–­ä¿¡æ¯çš„ Handler å’Œä¿å­˜è¯Šæ–­ä¿¡æ¯å†…å®¹çš„ Diagnostic ï¼Œåœ¨ Session å’Œ ParseSess ä¸­ï¼Œä¼šå…ˆè°ƒç”¨ SessionDiagnostic çš„ into_diagnostic() æ–¹æ³•ï¼Œè·å¾— DiagnosticBuilderï¼Œç„¶åè°ƒç”¨ DiagnoaticBuilder çš„ emit() æ–¹æ³•è¾“å‡ºè¯Šæ–­ä¿¡æ¯ï¼Œåœ¨ emit() æ–¹æ³•ä¸­ï¼Œä¼šè°ƒç”¨ DiagnoaticBuilder å†…ç½®çš„ Handler å¹¶å°† DiagnoaticBuilder ä¸­çš„  Diagnostic è¾“å‡ºåˆ°ç»ˆç«¯ã€‚</p>
<h2 id="æ€»ç»“"><a class="header" href="#æ€»ç»“">æ€»ç»“</a></h2>
<p>åœ¨æœ¬æ–‡ä¸­æˆ‘ä»¬åªæ¶‰çŒäº† Rustc ä¸­é”™è¯¯å¤„ç†æ¨¡å—å¾ˆå°çš„ä¸€éƒ¨åˆ†ï¼Œé€šè¿‡è¿™ä¸€éƒ¨åˆ†çš„æµ…çœ‹ï¼Œæˆ‘ä»¬å¤§æ¦‚çš„äº†è§£äº†ä¸€ä¸‹ Rustc ä¸­é”™è¯¯ä»å‡ºç°åˆ°å˜æˆè¯Šæ–­ä¿¡æ¯è¾“å‡ºåˆ°ç»ˆç«¯çš„æ•´ä¸ªæµç¨‹ã€‚æœ€åä»¥ä¸Šæ–‡ä¸­æåˆ°çš„ rustc_parser å’Œ rustc_type_checker ä¸ºä¾‹ï¼Œä¸€å¼ å›¾æ”¶å°¾ã€‚</p>
<p><img src="rustc/general/errors/./images/error-12.png" alt="" /></p>
<p>Rustc é”™è¯¯å¤„ç†æ¨¡å—çš„ä¸‰éƒ¨åˆ†: </p>
<ul>
<li>ç¼–è¯‘å™¨çš„å„ä¸ªéƒ¨åˆ†è‡ªå®šä¹‰é”™è¯¯çš„ç»“æ„ï¼Œä¿å­˜é”™è¯¯ä¿¡æ¯ã€‚</li>
<li>SessionDiagnostic è´Ÿè´£å°†å„éƒ¨åˆ†è‡ªå®šä¹‰é”™è¯¯çš„ç»“æ„è½¬æ¢ä¸º DiagnosticBuilderã€‚</li>
<li>Session/ParseSess è´Ÿè´£è°ƒç”¨ SessionDiagnostic æä¾›çš„æ¥å£è·å¾— DiagnosticBuilder ï¼Œå¹¶è°ƒç”¨ DiagnosticBuilder å†…ç½®çš„æ–¹æ³•è¾“å‡ºè¯Šæ–­ä¿¡æ¯ã€‚</li>
</ul>
<p>å¦‚æœè¿˜æ˜¯æœ‰ä¸€ç‚¹ç»•æ™•äº†ï¼Œåœ¨ä¸Šé¢è¿™ä¸ªå›¾ä¸Šå†åŠ ä¸€ç¬”ï¼Œé€šè¿‡çº¢è‰²çš„å°–å¤´æˆ‘ä»¬å¯ä»¥çœ‹åˆ° Rust ä¸­çš„ä¸€ä¸ªå¼‚å¸¸åŒ…å«çš„ä¿¡æ¯çš„ä»å‘ç”Ÿé”™è¯¯çš„åœ°æ–¹åˆ°å¼€å‘è€…é¢å‰çš„ä¸»è¦æµå‘ï¼š</p>
<p><img src="rustc/general/errors/./images/error-13.png" alt="" /></p>
<p>ä»ä¸Šå›¾å³é¢çš„éƒ¨åˆ†å¯ä»¥çœ‹åˆ°ï¼Œé”™è¯¯ä¿¡æ¯å¹¶ä¸æ˜¯ç›´æ¥ä» DiagnosticBuilder ä¸­å‘é€åˆ°å¼€å‘è€…é¢å‰çš„ï¼Œè€Œæ˜¯å…ˆä» Session å…œäº†ä¸ªåœˆå­ï¼Œé‚£ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšå‘¢ï¼Ÿè¿™é‡Œå…ˆåˆ¨ä¸ªå‘ï¼Œåç»­æˆ‘ä»¬å°†è¿›ä¸€æ­¥æ·±å…¥åˆ° Rustc çš„æºç å½“ä¸­å»ï¼Œè¯¦ç»†å‰–æè§£è¯»ä¸€ä¸‹å„éƒ¨åˆ†çš„æºç ç»“æ„å¹¶ä¸”ç†è§£ä¸€ä¸‹ Rustc çš„å¼€å‘è€…å¢åŠ å„ä¸ªéƒ¨åˆ†çš„åŠ¨æœºã€‚</p>
<h2 id="æœ¬æœŸæŒ–å‘"><a class="header" href="#æœ¬æœŸæŒ–å‘">æœ¬æœŸæŒ–å‘</a></h2>
<ul>
<li>Session å’Œ ParseSess åˆ°åº•æ˜¯ä»€ä¹ˆ ï¼Ÿ</li>
<li>ä¸ºä»€ä¹ˆæœç´¢ emit_err() æ²¡æœ‰æ¶‰åŠåˆ°è¯æ³•åˆ†æ Lexer å’Œä»£ç ç”Ÿæˆ CodeGen çš„éƒ¨åˆ†ï¼Œè¿™ä¸¤ä¸ªéƒ¨åˆ†çš„é”™è¯¯æ˜¯æ€ä¹ˆå¤„ç†çš„ ï¼Ÿ</li>
<li>EmissionGuarantee è¿™ä¸ªç»“æ„åœ¨é”™è¯¯å¤„ç†çš„è¿‡ç¨‹ä¸­æ˜¯åšä»€ä¹ˆçš„ ï¼Ÿ</li>
</ul>
<h2 id="å‚è€ƒ"><a class="header" href="#å‚è€ƒ">å‚è€ƒ</a></h2>
<ul>
<li>KusionStack: <a href="https://github.com/KusionStack/kusion">https://github.com/KusionStack/kusion</a></li>
<li>KCL é…ç½®è¯­è¨€ç¼–è¯‘å™¨: <a href="https://github.com/KusionStack/KCLVM">https://github.com/KusionStack/KCLVM</a></li>
<li>Rustc å®˜æ–¹æ–‡æ¡£: <a href="https://rustc-dev-guide.rust-lang.org/">https://rustc-dev-guide.rust-lang.org/</a></li>
<li>Rustc æºç : <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a></li>
<li>Rust Compiler Error Index: <a href="https://doc.rust-lang.org/error-index.html">https://doc.rust-lang.org/error-index.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sourcemap--span"><a class="header" href="#sourcemap--span">SourceMap &amp; Span</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustå¤–å›´å·¥å…·"><a class="header" href="#rustå¤–å›´å·¥å…·">Rustå¤–å›´å·¥å…·</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-open-source-project"><a class="header" href="#rust-open-source-project">Rust Open Source Project</a></h1>
<ul>
<li><a href="https://awesome-kusion.github.io/rust-code-book/open-source/KCLVM/index.html">KCLVM</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kcl"><a class="header" href="#kcl">KCL</a></h1>
<p><img src="https://img.shields.io/badge/license-Apache--2.0-green.svg" alt="license" /></p>
<p>Kusion Configuration Language (KCL) is an open source constraint-based record &amp; functional language mainly used in <a href="https://kusionstack.io">Kusion Stack</a>. KCL improves the writing of a large number of complicated configuration data and logic through mature programming language theory and practice, and simplifies and verifies the development and operation of configuration through declarative syntax combined with technical features such as static typing.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Well-designed</strong>: Independently designed syntax, semantics, runtime and system modules, providing core language elements such as configuration, schema, lambda and rule.</li>
<li><strong>Modeling</strong>: Schema-centric modeling abstraction.</li>
<li><strong>Easy to use</strong>: the language itself covers most configuration and policy functions.</li>
<li><strong>Stability</strong>: Static type system and custom rule constraints.</li>
<li><strong>Scalability</strong>: Configuration block definition ability and rich configuration merge coverage ability.</li>
<li><strong>Automation capabilities</strong>: Rich language-level CRUD API and multi-language API.</li>
<li><strong>High performance</strong>: The language compiler is implemented in Rust and C mainly with LLVM optimizer, supports compilation to native and WASM targets and executes efficiently.</li>
<li><strong>Cloud Native Affinity</strong>: Native support for <a href="https://github.com/KusionStack/kcl-openapi">OpenAPI</a> and Kubernetes CRD Specs to KCL conversion, support for Kubernetes YAML specification.</li>
<li><strong>Development friendly</strong>: Rich language tools (Lint, Test, Vet, Doc, etc.), <a href="https://github.com/KusionStack/vscode-kcl">IDE Plugins</a> and <a href="https://github.com/KusionStack/kcl-plugin">language plugins</a>.</li>
</ul>
<h2 id="what-is-it-for"><a class="header" href="#what-is-it-for">What is it for?</a></h2>
<p>You can use KCL to</p>
<ul>
<li>generate low-level configuration data like JSON, YAML, etc.</li>
<li>reduce boilerplate in configuration data with the schema modeling.</li>
<li>define schemas with rule constraints for configuration data and validate them automatically.</li>
<li>write configuration data separately and merge them using different strategies.</li>
<li>organize, simplify, unify and manage large configurations without side effects.</li>
<li>define your application delivery and operation ecosystem with <a href="https://kusionstack.io">Kusion Stack</a>.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><a href="https://github.com/KusionStack/KCLVM/releases">Download</a> the latest release from GitHub and add <code>{install-location}/kclvm/bin</code> to the environment <code>PATH</code>.</p>
<h2 id="quick-showcase"><a class="header" href="#quick-showcase">Quick Showcase</a></h2>
<p><code>./samples/fib.k</code> is an example of calculating the Fibonacci sequence.</p>
<pre><code class="language-kcl">schema Fib:
    n1: int = n - 1
    n2: int = n1 - 1
    n: int
    value: int

    if n &lt;= 1:
        value = 1
    elif n == 2:
        value = 1
    else:
        value = Fib {n: n1}.value + Fib {n: n2}.value

fib8 = Fib {n: 8}.value
</code></pre>
<p>We can execute the following command to get a YAML output.</p>
<pre><code>kcl ./samples/fib.k
</code></pre>
<p>YAML output</p>
<pre><code class="language-yaml">fib8: 21
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Detailed documentation is available at https://kusionstack.io</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>See <a href="open-source/KCLVM/./docs/dev_guide/1.about_this_guide.html">Developing Guide</a>.</p>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>See <a href="https://kusionstack.io/docs/governance/intro/roadmap#kclvm-%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92">KCLVM Roadmap</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>[Apache License Version 2.0]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é™„å½•"><a class="header" href="#é™„å½•">é™„å½•</a></h1>


                        <!-- å…¬ä¼—å· -->
                        <hr>
                                                <div id="giscus-container"></div>
                        <footer class="page-footer">
                            <span>Â© 2022 | <a href="https://github.com/awesome-kusion/rust-code-book"> Rust Source Code Analysis</a>, Only for study and communication</span>
                        </footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
                <script type="text/javascript" src="js/custom.js"></script>
                <script type="text/javascript" src="js/bigPicture.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
